<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hdlbits_Module_addsub</title>
    <link href="/2024/08/06/hdlbits-Module-addsub/"/>
    <url>/2024/08/06/hdlbits-Module-addsub/</url>
    
    <content type="html"><![CDATA[<h1 id="module_addsub">Module_addsub</h1><p>An adder-subtractor can be built from an adder by optionally negatingone of the inputs, which is equivalent to inverting the input thenadding 1. The net result is a circuit that can do two operations: (a + b+ 0) and (a + ~b + 1). See Wikipedia if you want a more detailedexplanation of how this circuit works.</p><p>Build the adder-subtractor below.</p><p>You are provided with a 16-bit adder module, which you need toinstantiate twice:</p><p>module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0]sum, output cout );</p><p>Use a 32-bit wide XOR gate to invert the b input whenever sub is 1.(This can also be viewed as b[31:0] XORed with sub replicated 32 times.See replication operator.). Also connect the sub input to the carry-inof the adder.</p><figure><img src="/images/Module_addsub.png" title="Module_addsub"alt="Module_addsub" /><figcaption aria-hidden="true">Module_addsub</figcaption></figure><blockquote><p>Hint</p><blockquote><p>An XOR gate can also be viewed as a programmable inverter, where oneinput controls whether the other should be inverted.</p></blockquote></blockquote><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">input</span> sub,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum<br>);<br><br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] bb;<br>    <span class="hljs-keyword">wire</span> co;<br>    <span class="hljs-keyword">assign</span> bb = &#123; &#123;<span class="hljs-number">32</span>&#123;sub&#125;&#125; &#125; ^ b;<br>    add16 add1(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.b</span>(bb[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.cin</span>(sub), <span class="hljs-variable">.cout</span>(co), <span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]));<br>    add16 add2(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]), <span class="hljs-variable">.b</span>(bb[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]), <span class="hljs-variable">.cin</span>(co), <span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]));<br>    <br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits_Module_cseladd</title>
    <link href="/2024/08/06/hdlbits-Module-cseladd/"/>
    <url>/2024/08/06/hdlbits-Module-cseladd/</url>
    
    <content type="html"><![CDATA[<h1 id="module_cseladd">Module_cseladd</h1><p>One drawback of the ripple carry adder (See previous exercise) isthat the delay for an adder to compute the carry out (from the carry-in,in the worst case) is fairly slow, and the second-stage adder cannotbegin computing its carry-out until the first-stage adder has finished.This makes the adder slow. One improvement is a carry-select adder,shown below. The first-stage adder is the same as before, but weduplicate the second-stage adder, one assuming carry-in=0 and oneassuming carry-in=1, then using a fast 2-to-1 multiplexer to selectwhich result happened to be correct.</p><p>In this exercise, you are provided with the same module add16 as theprevious exercise, which adds two 16-bit numbers with carry-in andproduces a carry-out and 16-bit sum. You must instantiate three of theseto build the carry-select adder, using your own 16-bit 2-to-1multiplexer.</p><p>Connect the modules together as shown in the diagram below. Theprovided module add16 has the following declaration:</p><p>module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0]sum, output cout );</p><figure><img src="/images/Module_cseladd.png" title="Module_cseladd"alt="Module_cseladd" /><figcaption aria-hidden="true">Module_cseladd</figcaption></figure><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum<br>);<br><br>    <span class="hljs-keyword">wire</span> sel;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] s1, s2;<br>    add16 add1(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.cin</span>(<span class="hljs-number">0</span>), <span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.cout</span>(sel));<br>    add16 add2(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]), <span class="hljs-variable">.b</span>(b[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]), <span class="hljs-variable">.cin</span>(<span class="hljs-number">0</span>), <span class="hljs-variable">.sum</span>(s1) );<br>    add16 add3(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]), <span class="hljs-variable">.b</span>(b[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]), <span class="hljs-variable">.cin</span>(<span class="hljs-number">1</span>), <span class="hljs-variable">.sum</span>(s2) );<br>    <br>    <span class="hljs-keyword">assign</span> sum[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>] = &#123; &#123;<span class="hljs-number">16</span>&#123;sel&#125;&#125; &#125; &amp; s2 | &#123; ~&#123;<span class="hljs-number">16</span>&#123;sel&#125;&#125; &#125; &amp; s1;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits_Module_fadd</title>
    <link href="/2024/08/06/hdlbits-Module-fadd/"/>
    <url>/2024/08/06/hdlbits-Module-fadd/</url>
    
    <content type="html"><![CDATA[<h1 id="module_fadd">Module_fadd</h1><p>In this exercise, you will create a circuit with two levels ofhierarchy. Your top_module will instantiate two copies of add16(provided), each of which will instantiate 16 copies of add1 (which youmust write). Thus, you must write two modules: top_module and add1.</p><p>Like module_add, you are given a module add16 that performs a 16-bitaddition. You must instantiate two of them to create a 32-bit adder. Oneadd16 module computes the lower 16 bits of the addition result, whilethe second add16 module computes the upper 16 bits of the result. Your32-bit adder does not need to handle carry-in (assume 0) or carry-out(ignored).</p><p>Connect the add16 modules together as shown in the diagram below. Theprovided module add16 has the following declaration:</p><p>module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0]sum, output cout );</p><p>Within each add16, 16 full adders (module add1, not provided) areinstantiated to actually perform the addition. You must write the fulladder module that has the following declaration:</p><p>module add1 ( input a, input b, input cin, output sum, output cout);</p><p>Recall that a full adder computes the sum and carry-out ofa+b+cin.</p><p>In summary, there are three modules in this design:</p><ul><li>top_module — Your top-level module that contains two of...</li><li>add16, provided — A 16-bit adder module that is composed of 16of...</li><li>add1 — A 1-bit full adder module.</li></ul><p>If your submission is missing a module add1, you will get an errormessage that says Error (12006): Node instance "user_fadd[0].a1"instantiates undefined entity "add1".</p><figure><img src="/images/Module_fadd.png" title="Module_fadd"alt="Module_fadd" /><figcaption aria-hidden="true">Module_fadd</figcaption></figure><blockquote><p>Hint</p><blockquote><p>Full adder equations:</p><p>sum = a ^ b ^ cin</p><p>cout = a&amp;b | a&amp;cin | b&amp;cin</p></blockquote></blockquote><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum<br>);<span class="hljs-comment">//</span><br><br>    <span class="hljs-keyword">wire</span> cout;<br>    add16 add1(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.cin</span>(<span class="hljs-number">1&#x27;b0</span>), <span class="hljs-variable">.cout</span>(cout), <span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]));<br>    add16 add2(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]), <span class="hljs-variable">.b</span>(b[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]), <span class="hljs-variable">.cin</span>(cout), <span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]));<br>    <br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> add1 ( <span class="hljs-keyword">input</span> a, <span class="hljs-keyword">input</span> b, <span class="hljs-keyword">input</span> cin,   <span class="hljs-keyword">output</span> sum, <span class="hljs-keyword">output</span> cout );<br><br><span class="hljs-comment">// Full adder module here</span><br><span class="hljs-keyword">assign</span> sum  = a^b^cin;<br>    <span class="hljs-keyword">assign</span> cout = a&amp;b | a&amp;cin | b&amp;cin;<br>    <br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits_Module_add</title>
    <link href="/2024/08/06/hdlbits-Module-add/"/>
    <url>/2024/08/06/hdlbits-Module-add/</url>
    
    <content type="html"><![CDATA[<h1 id="module_add">Module_add</h1><p>You are given a module add16 that performs a 16-bit addition.Instantiate two of them to create a 32-bit adder. One add16 modulecomputes the lower 16 bits of the addition result, while the secondadd16 module computes the upper 16 bits of the result, after receivingthe carry-out from the first adder. Your 32-bit adder does not need tohandle carry-in (assume 0) or carry-out (ignored), but the internalmodules need to in order to function correctly. (In other words, theadd16 module performs 16-bit a + b + cin, while your module performs32-bit a + b).</p><p>Connect the modules together as shown in the diagram below. Theprovided module add16 has the following declaration:</p><p>module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0]sum, output cout );</p><figure><img src="/images/Module_add.png" title="Module_add" alt="Module_add" /><figcaption aria-hidden="true">Module_add</figcaption></figure><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum<br>);<br><span class="hljs-keyword">wire</span> cout;<br>    add16 add1(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.cin</span>(<span class="hljs-number">1&#x27;b0</span>), <span class="hljs-variable">.cout</span>(cout), <span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]));<br>    add16 add2(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]), <span class="hljs-variable">.b</span>(b[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]), <span class="hljs-variable">.cin</span>(cout), <span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]));<br>    <br>    <br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits_Module_shift8</title>
    <link href="/2024/08/06/hdlbits-Module-shift8/"/>
    <url>/2024/08/06/hdlbits-Module-shift8/</url>
    
    <content type="html"><![CDATA[<h1 id="module_shift8">Module_shift8</h1><p>Instead of module ports being only single pins, we now have moduleswith vectors as ports, to which you will attach wire vectors instead ofplain wires. Like everywhere else in Verilog, the vector length of theport does not have to match the wire connecting to it, but this willcause zero-padding or trucation of the vector. This exercise does notuse connections with mismatched vector lengths.</p><p>You are given a module my_dff8 with two inputs and one output (thatimplements a set of 8 D flip-flops). Instantiate three of them, thenchain them together to make a 8-bit wide shift register of length 3. Inaddition, create a 4-to-1 multiplexer (not provided) that chooses whatto output depending on sel[1:0]: The value at the input d, after thefirst, after the second, or after the third D flip-flop. (Essentially,sel selects how many cycles to delay the input, from zero to three clockcycles.)</p><p>The module provided to you is: module my_dff8 ( input clk, input[7:0] d, output [7:0] q );</p><p>The multiplexer is not provided. One possible way to write one isinside an always block with a case statement inside.</p><figure><img src="/images/Module_shift8.png" title="Module_shift8"alt="Module_shift8" /><figcaption aria-hidden="true">Module_shift8</figcaption></figure><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module ( <br>    <span class="hljs-keyword">input</span> clk, <br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d, <br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel, <br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q <br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q1;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q2;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q3;<br>    my_dff8 dff1(clk, d, q1);<br>    my_dff8 dff2(clk, q1, q2);<br>    my_dff8 dff3(clk, q2, q3);<br>    <span class="hljs-comment">// 当时不会写case语句doge</span><br>    <span class="hljs-keyword">assign</span> q = &#123; &#123;<span class="hljs-number">8</span>&#123;sel[<span class="hljs-number">0</span>]&#125;&#125; &#125; &amp; &#123; &#123;<span class="hljs-number">8</span>&#123;sel[<span class="hljs-number">1</span>]&#125;&#125; &#125; &amp; q3 | &#123; ~&#123;<span class="hljs-number">8</span>&#123;sel[<span class="hljs-number">0</span>]&#125;&#125; &#125; &amp; &#123; &#123;<span class="hljs-number">8</span>&#123;sel[<span class="hljs-number">1</span>]&#125;&#125; &#125; &amp; q2 | &#123; &#123;<span class="hljs-number">8</span>&#123;sel[<span class="hljs-number">0</span>]&#125;&#125; &#125; &amp; &#123; ~&#123;<span class="hljs-number">8</span>&#123;sel[<span class="hljs-number">1</span>]&#125;&#125; &#125; &amp; q1 | &#123; ~&#123;<span class="hljs-number">8</span>&#123;sel[<span class="hljs-number">0</span>]&#125;&#125; &#125; &amp; &#123; ~&#123;<span class="hljs-number">8</span>&#123;sel[<span class="hljs-number">1</span>]&#125;&#125; &#125; &amp; d;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits_Module_shift</title>
    <link href="/2024/08/06/hdlbits-Module-shift/"/>
    <url>/2024/08/06/hdlbits-Module-shift/</url>
    
    <content type="html"><![CDATA[<h1 id="module_shift">Module_shift</h1><p>You are given a module my_dff with two inputs and one output (thatimplements a D flip-flop). Instantiate three of them, then chain themtogether to make a shift register of length 3. The clk port needs to beconnected to all instances.</p><p>The module provided to you is: module my_dff ( input clk, input d,output q );</p><p>Note that to make the internal connections, you will need to declaresome wires. Be careful about naming your wires and module instances: thenames must be unique.</p><figure><img src="/images/Module_shift.png" title="Module_shift"alt="Module_shift" /><figcaption aria-hidden="true">Module_shift</figcaption></figure><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module ( <span class="hljs-keyword">input</span> clk, <span class="hljs-keyword">input</span> d, <span class="hljs-keyword">output</span> q );<br>    <span class="hljs-keyword">wire</span> q1,q2;<br>    my_dff dffins1(clk, d, q1);<br>    my_dff dffins2(clk, q1, q2);<br>    my_dff dffins3(clk, q2, q);<br><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits_Module_name</title>
    <link href="/2024/08/06/hdlbits-Module-name/"/>
    <url>/2024/08/06/hdlbits-Module-name/</url>
    
    <content type="html"><![CDATA[<h1 id="module_name">Module_name</h1><p>You are given a module named mod_a that has 2 outputs and 4 inputs,in some order. You must connect the 6 ports by name to your top-levelmodule's ports:</p><table><thead><tr class="header"><th>Port in mod_a</th><th>Port in top_module</th></tr></thead><tbody><tr class="odd"><td>output out1</td><td>out1</td></tr><tr class="even"><td>output out2</td><td>out2</td></tr><tr class="odd"><td>input in1</td><td>a</td></tr><tr class="even"><td>input in2</td><td>b</td></tr><tr class="odd"><td>input in3</td><td>c</td></tr><tr class="even"><td>input in4</td><td>d</td></tr></tbody></table><p>You are given the following module:</p><p>module mod_a ( output out1, output out2, input in1, input in2, inputin3, input in4);</p><figure><img src="/images/Module_name.png" title="Module_name"alt="Module_name" /><figcaption aria-hidden="true">Module_name</figcaption></figure><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module ( <br>    <span class="hljs-keyword">input</span> a, <br>    <span class="hljs-keyword">input</span> b, <br>    <span class="hljs-keyword">input</span> c,<br>    <span class="hljs-keyword">input</span> d,<br>    <span class="hljs-keyword">output</span> out1,<br>    <span class="hljs-keyword">output</span> out2<br>);<br>    mod_a instance_a(<span class="hljs-variable">.out1</span>(out1), <span class="hljs-variable">.out2</span>(out2), <span class="hljs-variable">.in1</span>(a), <span class="hljs-variable">.in2</span>(b), <span class="hljs-variable">.in3</span>(c), <span class="hljs-variable">.in4</span>(d));<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits_Module_pos</title>
    <link href="/2024/08/06/hdlbits-Module-pos/"/>
    <url>/2024/08/06/hdlbits-Module-pos/</url>
    
    <content type="html"><![CDATA[<h1 id="module-pos">Module pos</h1><p>You are given a module named mod_a that has 2 outputs and 4 inputs,in that order. You must connect the 6 ports by position to yourtop-level module's ports out1, out2, a, b, c, and d, in that order.</p><p>You are given the following module:</p><p>module mod_a ( output, output, input, input, input, input );</p><figure><img src="/images/Module_pos.png" title="Module_pos" alt="Module_pos" /><figcaption aria-hidden="true">Module_pos</figcaption></figure><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module ( <br>    <span class="hljs-keyword">input</span> a, <br>    <span class="hljs-keyword">input</span> b, <br>    <span class="hljs-keyword">input</span> c,<br>    <span class="hljs-keyword">input</span> d,<br>    <span class="hljs-keyword">output</span> out1,<br>    <span class="hljs-keyword">output</span> out2<br>);<br>    mod_a instance_a(out1, out2, a, b, c, d);<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits_Module</title>
    <link href="/2024/08/06/hdlbits-Module/"/>
    <url>/2024/08/06/hdlbits-Module/</url>
    
    <content type="html"><![CDATA[<h1 id="module">Module</h1><p>https://hdlbits.01xz.net/wiki/Module</p><p>By now, you're familiar with a module, which is a circuit thatinteracts with its outside through input and output ports. Larger, morecomplex circuits are built by composing bigger modules out of smallermodules and other pieces (such as assign statements and always blocks)connected together. This forms a hierarchy, as modules can containinstances of other modules.</p><p>The figure below shows a very simple circuit with a sub-module. Inthis exercise, create one instance of module mod_a, then connect themodule's three pins (in1, in2, and out) to your top-level module's threeports (wires a, b, and out). The module mod_a is provided for you — youmust instantiate it.</p><p>When connecting modules, only the ports on the module are important.You do not need to know the code inside the module. The code for modulemod_a looks like this:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a ( <span class="hljs-keyword">input</span> in1, <span class="hljs-keyword">input</span> in2, <span class="hljs-keyword">output</span> out );<br>    <span class="hljs-comment">// Module body</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>The hierarchy of modules is created by instantiating one moduleinside another, as long as all of the modules used belong to the sameproject (so the compiler knows where to find the module). The code forone module is not written inside another module's body (Code fordifferent modules are not nested).</p><p>You may connect signals to the module by port name or port position.For extra practice, try both methods.</p><figure><img src="/images/Module.png" title="Module" alt="Module" /><figcaption aria-hidden="true">Module</figcaption></figure><h2 id="connecting-signals-to-module-ports">Connecting Signals to ModulePorts</h2><p>There are two commonly-used methods to connect a wire to a port: byposition or by name. By position</p><p>The syntax to connect wires to ports by position should be familiar,as it uses a C-like syntax. When instantiating a module, ports areconnected left to right according to the module's declaration. Forexample: <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">mod_a instance1 ( wa, wb, wc );<br></code></pre></td></tr></table></figure> This instantiates a module of type mod_a andgives it an instance name of "instance1", then connects signal wa(outside the new module) to the first port (in1) of the new module, wbto the second port (in2), and wc to the third port (out). One drawbackof this syntax is that if the module's port list changes, allinstantiations of the module will also need to be found and changed tomatch the new module. By name</p><p>Connecting signals to a module's ports by name allows wires to remaincorrectly connected even if the port list changes. This syntax is moreverbose, however. <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">mod_a instance2 ( <span class="hljs-variable">.out</span>(wc), <span class="hljs-variable">.in1</span>(wa), <span class="hljs-variable">.in2</span>(wb) );<br></code></pre></td></tr></table></figure> The above line instantiates a module oftype mod_a named "instance2", then connects signal wa (outside themodule) to the port named in1, wb to the port named in2, and wc to theport named out. Notice how the ordering of ports is irrelevant herebecause the connection will be made to the correct name, regardless ofits position in the sub-module's port list. Also notice the periodimmediately preceding the port name in this syntax.</p><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module ( <span class="hljs-keyword">input</span> a, <span class="hljs-keyword">input</span> b, <span class="hljs-keyword">output</span> out );<br>    mod_a instance_a(<span class="hljs-variable">.in1</span>(a), <span class="hljs-variable">.in2</span>(b), <span class="hljs-variable">.out</span>(out));<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Vector5</title>
    <link href="/2024/08/03/hdlbits-Vector5/"/>
    <url>/2024/08/03/hdlbits-Vector5/</url>
    
    <content type="html"><![CDATA[<h1 id="vector5">Vector5</h1><p>Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwiseone-bit comparisons in the 25-bit output vector. The output should be 1if the two bits being compared are equal. <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog">out[<span class="hljs-number">24</span>] = ~a ^ a;   <span class="hljs-comment">// a == a, so out[24] is always 1.</span><br>out[<span class="hljs-number">23</span>] = ~a ^ b;<br>out[<span class="hljs-number">22</span>] = ~a ^ c;<br>...<br>out[ <span class="hljs-number">1</span>] = ~e ^ d;<br>out[ <span class="hljs-number">0</span>] = ~e ^ e;<br></code></pre></td></tr></table></figure></p><figure><img src="/images/Vector5.png" title="Vector5" alt="Vector5" /><figcaption aria-hidden="true">Vector5</figcaption></figure><p>As the diagram shows, this can be done more easily using thereplication and concatenation operators.</p><ul><li>The top vector is a concatenation of 5 repeats of each input</li><li>The bottom vector is 5 repeats of a concatenation of the 5inputs</li></ul><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> a, b, c, d, e,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">24</span>:<span class="hljs-number">0</span>] out );<span class="hljs-comment">//</span><br><br>    <span class="hljs-comment">// The output is XNOR of two vectors created by </span><br>    <span class="hljs-comment">// concatenating and replicating the five inputs.</span><br>    <span class="hljs-comment">// assign out = ~&#123; ... &#125; ^ &#123; ... &#125;;</span><br>    <span class="hljs-keyword">assign</span> out = ~&#123; &#123;<span class="hljs-number">5</span>&#123;a&#125;&#125;, &#123;<span class="hljs-number">5</span>&#123;b&#125;&#125;, &#123;<span class="hljs-number">5</span>&#123;c&#125;&#125;, &#123;<span class="hljs-number">5</span>&#123;d&#125;&#125;, &#123;<span class="hljs-number">5</span>&#123;e&#125;&#125; &#125; ^ &#123; &#123;<span class="hljs-number">5</span>&#123;a,b,c,d,e&#125;&#125; &#125;;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Vector4</title>
    <link href="/2024/08/03/hdlbits-Vector4/"/>
    <url>/2024/08/03/hdlbits-Vector4/</url>
    
    <content type="html"><![CDATA[<h1 id="vector4">Vector4</h1><p>The concatenation operator allowed concatenating together vectors toform a larger vector. But sometimes you want the same thing concatenatedtogether many times, and it is still tedious to do something like assign<strong>a = {b,b,b,b,b,b};</strong>. The replication operator allowsrepeating a vector and concatenating them together: <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">&#123;num&#123;vector&#125;&#125;<br></code></pre></td></tr></table></figure> Thisreplicates vector by num times. num must be a constant. Both sets ofbraces are required.</p><p>Examples: <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog">&#123;<span class="hljs-number">5</span>&#123;<span class="hljs-number">1&#x27;b1</span>&#125;&#125;           <span class="hljs-comment">// 5&#x27;b11111 (or 5&#x27;d31 or 5&#x27;h1f)</span><br>&#123;<span class="hljs-number">2</span>&#123;a,b,c&#125;&#125;          <span class="hljs-comment">// The same as &#123;a,b,c,a,b,c&#125;</span><br>&#123;<span class="hljs-number">3&#x27;d5</span>, &#123;<span class="hljs-number">2</span>&#123;<span class="hljs-number">3&#x27;d6</span>&#125;&#125;&#125;   <span class="hljs-comment">// 9&#x27;b101_110_110. It&#x27;s a concatenation of 101 with</span><br>                    <span class="hljs-comment">// the second vector, which is two copies of 3&#x27;b110.</span><br></code></pre></td></tr></table></figure></p><h1 id="practice">Practice</h1><p>One common place to see a replication operator is when sign-extendinga smaller number to a larger one, while preserving its signed value.This is done by replicating the sign bit (the most significant bit) ofthe smaller number to the left. For example, sign-extending 4'b0101 (5)to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3)to 8 bits results in 8'b11111101 (-3).</p><p>Build a circuit that sign-extends an 8-bit number to 32 bits. Thisrequires a concatenation of 24 copies of the sign bit (i.e., replicatebit[7] 24 times) followed by the 8-bit number itself.</p><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out );<span class="hljs-comment">//</span><br><br>    <span class="hljs-comment">// assign out = &#123; replicate-sign-bit , the-input &#125;;</span><br>    <span class="hljs-keyword">assign</span> out = &#123; &#123;<span class="hljs-number">24</span>&#123;in[<span class="hljs-number">7</span>]&#125;&#125;, in &#125;; <span class="hljs-comment">// 一个大括号都不能少</span><br><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Vectorr</title>
    <link href="/2024/08/03/hdlbits-Vectorr/"/>
    <url>/2024/08/03/hdlbits-Vectorr/</url>
    
    <content type="html"><![CDATA[<h1 id="vectorr">Vectorr</h1><p>Given an 8-bit input vector [7:0], reverse its bit ordering.</p><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] out<br>);<br>    <span class="hljs-keyword">assign</span> out = &#123;in[<span class="hljs-number">0</span>], in[<span class="hljs-number">1</span>], in[<span class="hljs-number">2</span>], in[<span class="hljs-number">3</span>], in[<span class="hljs-number">4</span>], in[<span class="hljs-number">5</span>], in[<span class="hljs-number">6</span>], in[<span class="hljs-number">7</span>]&#125;;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Vector3</title>
    <link href="/2024/08/03/hdlbits-Vector3/"/>
    <url>/2024/08/03/hdlbits-Vector3/</url>
    
    <content type="html"><![CDATA[<h1 id="vector3">Vector3</h1><p>Part selection was used to select portions of a vector. Theconcatenation operator {a,b,c} is used to create larger vectors byconcatenating smaller portions of a vector together. <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">&#123;<span class="hljs-number">3&#x27;b111</span>, <span class="hljs-number">3&#x27;b000</span>&#125; =&gt; <span class="hljs-number">6&#x27;b111000</span><br>&#123;<span class="hljs-number">1&#x27;b1</span>, <span class="hljs-number">1&#x27;b0</span>, <span class="hljs-number">3&#x27;b101</span>&#125; =&gt; <span class="hljs-number">5&#x27;b10101</span><br>&#123;<span class="hljs-number">4&#x27;ha</span>, <span class="hljs-number">4&#x27;d10</span>&#125; =&gt; <span class="hljs-number">8&#x27;b10101010</span>     <span class="hljs-comment">// 4&#x27;ha and 4&#x27;d10 are both 4&#x27;b1010 in binary</span><br></code></pre></td></tr></table></figure>Concatenation needs to know the width of every component (or how wouldyou know the length of the result?). Thus, {1, 2, 3} is illegal andresults in the error message: unsized constants are not allowed inconcatenations.</p><p>The concatenation operator can be used on both the left and rightsides of assignments. <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] in;<br><span class="hljs-keyword">output</span> [<span class="hljs-number">23</span>:<span class="hljs-number">0</span>] out;<br><span class="hljs-keyword">assign</span> &#123;out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], out[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>]&#125; = in;         <span class="hljs-comment">// Swap two bytes. Right side and left side are both 16-bit vectors.</span><br><span class="hljs-keyword">assign</span> out[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] = &#123;in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], in[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>]&#125;;    <span class="hljs-comment">// This is the same thing.</span><br><span class="hljs-keyword">assign</span> out = &#123;in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], in[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>]&#125;;       <span class="hljs-comment">// This is different. The 16-bit vector on the right is extended to</span><br>                                        <span class="hljs-comment">// match the 24-bit vector on the left, so out[23:16] are zero.</span><br>                                        <span class="hljs-comment">// In the first two examples, out[23:16] are not assigned.</span><br></code></pre></td></tr></table></figure></p><h1 id="practice">Practice</h1><p>Given several input vectors, concatenate them together then splitthem up into several output vectors. There are six 5-bit input vectors:a, b, c, d, e, and f, for a total of 30 bits of input. There are four8-bit output vectors: w, x, y, and z, for 32 bits of output. The outputshould be a concatenation of the input vectors followed by two 1bits:</p><figure><img src="/images/Vector3.png" title="Vector3" alt="Vector3" /><figcaption aria-hidden="true">Vector3</figcaption></figure><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] a, b, c, d, e, f,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] w, x, y, z );<span class="hljs-comment">//</span><br><br>    <span class="hljs-comment">// assign &#123; ... &#125; = &#123; ... &#125;;</span><br>    <span class="hljs-keyword">assign</span> &#123;w, x, y, z&#125; = &#123;a, b, c, d, e, f, <span class="hljs-number">2&#x27;b11</span>&#125;;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Gates4</title>
    <link href="/2024/08/03/hdlbits-Gates4/"/>
    <url>/2024/08/03/hdlbits-Gates4/</url>
    
    <content type="html"><![CDATA[<h1 id="gates4">Gates4</h1><p>Build a combinational circuit with four inputs, in[3:0].</p><p>There are 3 outputs:</p><ul><li>out_and: output of a 4-input AND gate.</li><li>out_or: output of a 4-input OR gate.</li><li>out_xor: output of a 4-input XOR gate.</li></ul><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> out_and,<br>    <span class="hljs-keyword">output</span> out_or,<br>    <span class="hljs-keyword">output</span> out_xor<br>);<br>    <span class="hljs-keyword">assign</span> out_and = in[<span class="hljs-number">0</span>] &amp; in[<span class="hljs-number">1</span>] &amp; in[<span class="hljs-number">2</span>] &amp; in[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">assign</span> out_or  = in[<span class="hljs-number">0</span>] | in[<span class="hljs-number">1</span>] | in[<span class="hljs-number">2</span>] | in[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">assign</span> out_xor = in[<span class="hljs-number">0</span>] ^ in[<span class="hljs-number">1</span>] ^ in[<span class="hljs-number">2</span>] ^ in[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Vectorgates</title>
    <link href="/2024/08/03/hdlbits-Vectorgates/"/>
    <url>/2024/08/03/hdlbits-Vectorgates/</url>
    
    <content type="html"><![CDATA[<h1 id="vectorgates">Vectorgates</h1><p>Build a circuit that has two 3-bit inputs that computes thebitwise-OR of the two vectors, the logical-OR of the two vectors, andthe inverse (NOT) of both vectors. Place the inverse of b in the upperhalf of out_not (i.e., bits [5:3]), and the inverse of a in the lowerhalf.</p><h2 id="bitwise-vs.-logical-operators">Bitwise vs. LogicalOperators</h2><p>Earlier, we mentioned that there are bitwise and logical versions ofthe various boolean operators (e.g., norgate). When using vectors, thedistinction between the two operator types becomes important. A bitwiseoperation between two N-bit vectors replicates the operation for eachbit of the vector and produces a N-bit output, while a logical operationtreats the entire vector as a boolean value (true = non-zero, false =zero) and produces a 1-bit output.</p><p>Look at the simulation waveforms at how the bitwise-OR and logical-ORdiffer.</p><figure><img src="/images/Vectorgates.png" title="Vectorgates"alt="Vectorgates" /><figcaption aria-hidden="true">Vectorgates</figcaption></figure><blockquote><p>Hint</p></blockquote><blockquote><blockquote><p>Even though you cannot assign to a wire more than once, you can use apart select on the left-hand-side of an assign. You don't need to assignto the entire vector all in one statement.</p></blockquote></blockquote><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] out_or_bitwise,<br>    <span class="hljs-keyword">output</span> out_or_logical,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] out_not<br>);<br><span class="hljs-keyword">assign</span> out_or_bitwise = a|b;<br>    <span class="hljs-keyword">assign</span> out_or_logical = a || b;<br>    <span class="hljs-keyword">assign</span> out_not = &#123;~b, ~a&#125;;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Vector2</title>
    <link href="/2024/08/03/hdlbits-Vector2/"/>
    <url>/2024/08/03/hdlbits-Vector2/</url>
    
    <content type="html"><![CDATA[<h1 id="vector2">Vector2</h1><p>A 32-bit vector can be viewed as containing 4 bytes (bits [31:24],[23:16], etc.). Build a circuit that will reverse the byte ordering ofthe 4-byte word.</p><p>AaaaaaaaBbbbbbbbCcccccccDddddddd =&gt;DdddddddCcccccccBbbbbbbbAaaaaaaa</p><p>This operation is often used when the endianness of a piece of dataneeds to be swapped, for example between little-endian x86 systems andthe big-endian formats used in many Internet protocols.</p><blockquote><p>Hint</p></blockquote><blockquote><blockquote><p>Part-select can be used on both the left side and right side of anassignment.</p></blockquote></blockquote><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out );<span class="hljs-comment">//</span><br><br>    <span class="hljs-comment">// assign out[31:24] = ...;</span><br>    <span class="hljs-keyword">assign</span> out[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>] = in[ <span class="hljs-number">7</span>: <span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">assign</span> out[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>] = in[<span class="hljs-number">15</span>: <span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">assign</span> out[<span class="hljs-number">15</span>: <span class="hljs-number">8</span>] = in[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>];<br>    <span class="hljs-keyword">assign</span> out[ <span class="hljs-number">7</span>: <span class="hljs-number">0</span>] = in[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>];<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Vector1</title>
    <link href="/2024/08/03/hdlbits-Vector1/"/>
    <url>/2024/08/03/hdlbits-Vector1/</url>
    
    <content type="html"><![CDATA[<h1 id="vector1">Vector1</h1><p>Vectors are used to group related signals using one name to make itmore convenient to manipulate. For example, wire [7:0] w; declares an8-bit vector named w that is equivalent to having 8 separate wires.</p><h2 id="declaring-vectors">Declaring Vectors</h2><p>Vectors must be declared:</p><p>type [upper:lower] vector_name;</p><p>type specifies the datatype of the vector. This is usually wire orreg. If you are declaring a input or output port, the type canadditionally include the port type (e.g., input or output) as well. Someexamples: <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] w;         <span class="hljs-comment">// 8-bit wire</span><br><span class="hljs-keyword">reg</span>  [<span class="hljs-number">4</span>:<span class="hljs-number">1</span>] x;         <span class="hljs-comment">// 4-bit reg</span><br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">0</span>:<span class="hljs-number">0</span>] y;   <span class="hljs-comment">// 1-bit reg that is also an output port (this is still a vector)</span><br><span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:-<span class="hljs-number">2</span>] z;  <span class="hljs-comment">// 6-bit wire input (negative ranges are allowed)</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] a;       <span class="hljs-comment">// 4-bit output wire. Type is &#x27;wire&#x27; unless specified otherwise.</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">0</span>:<span class="hljs-number">7</span>] b;         <span class="hljs-comment">// 8-bit wire where b[0] is the most-significant bit.</span><br></code></pre></td></tr></table></figure></p><p>The endianness (or, informally, "direction") of a vector is whetherthe the least significant bit has a lower index (little-endian, e.g.,[3:0]) or a higher index (big-endian, e.g., [0:3]). In Verilog, once avector is declared with a particular endianness, it must always be usedthe same way. e.g., writing vec[0:3] when vec is declared wire [3:0]vec; is illegal. Being consistent with endianness is good practice, asweird bugs occur if vectors of different endianness are assigned or usedtogether.</p><h2 id="implicit-nets">Implicit nets</h2><p>Implicit nets are often a source of hard-to-detect bugs. In Verilog,net-type signals can be implicitly created by an assign statement or byattaching something undeclared to a module port. Implicit nets arealways one-bit wires and causes bugs if you had intended to use avector. Disabling creation of implicit nets can be done using the`default_nettype none directive.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] a, c;   <span class="hljs-comment">// Two vectors</span><br><span class="hljs-keyword">assign</span> a = <span class="hljs-number">3&#x27;b101</span>;  <span class="hljs-comment">// a = 101</span><br><span class="hljs-keyword">assign</span> b = a;       <span class="hljs-comment">// b =   1  implicitly-created wire</span><br><span class="hljs-keyword">assign</span> c = b;       <span class="hljs-comment">// c = 001  &lt;-- bug</span><br>my_module i1 (d,e); <span class="hljs-comment">// d and e are implicitly one-bit wide if not declared.</span><br>                    <span class="hljs-comment">// This could be a bug if the port was intended to be a vector.</span><br></code></pre></td></tr></table></figure><p>Adding `default_nettype none would make the second line of code anerror, which makes the bug more visible.</p><h2 id="unpacked-vs.-packed-arrays">Unpacked vs. Packed Arrays</h2><p>You may have noticed that in declarations, the vector indices arewritten before the vector name. This declares the "packed" dimensions ofthe array, where the bits are "packed" together into a blob (this isrelevant in a simulator, but not in hardware). The unpacked dimensionsare declared after the name. They are generally used to declare memoryarrays. Since ECE253 didn't cover memory arrays, we have not used packedarrays in this course. Seehttp://www.asic-world.com/systemverilog/data_types10.html for moredetails.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] mem [<span class="hljs-number">255</span>:<span class="hljs-number">0</span>];   <span class="hljs-comment">// 256 unpacked elements, each of which is a 8-bit packed vector of reg.</span><br><span class="hljs-keyword">reg</span> mem2 [<span class="hljs-number">28</span>:<span class="hljs-number">0</span>];         <span class="hljs-comment">// 29 unpacked elements, each of which is a 1-bit reg.</span><br></code></pre></td></tr></table></figure><h2 id="accessing-vector-elements-part-select">Accessing VectorElements: Part-Select</h2><p>Accessing an entire vector is done using the vector name. Forexample:</p><p>assign w = a;</p><p>takes the entire 4-bit vector a and assigns it to the entire 8-bitvector w (declarations are taken from above). If the lengths of theright and left sides don't match, it is zero-extended or truncated asappropriate.</p><p>The part-select operator can be used to access a portion of a vector:<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog">w[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]      <span class="hljs-comment">// Only the lower 4 bits of w</span><br>x[<span class="hljs-number">1</span>]        <span class="hljs-comment">// The lowest bit of x</span><br>x[<span class="hljs-number">1</span>:<span class="hljs-number">1</span>]      <span class="hljs-comment">// ...also the lowest bit of x</span><br>z[-<span class="hljs-number">1</span>:-<span class="hljs-number">2</span>]    <span class="hljs-comment">// Two lowest bits of z</span><br>b[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]      <span class="hljs-comment">// Illegal. Vector part-select must match the direction of the declaration.</span><br>b[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]      <span class="hljs-comment">// The *upper* 4 bits of b.</span><br><span class="hljs-keyword">assign</span> w[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] = b[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>];    <span class="hljs-comment">// Assign upper 4 bits of b to lower 4 bits of w. w[3]=b[0], w[2]=b[1], etc.</span><br></code></pre></td></tr></table></figure></p><h1 id="practice">Practice</h1><p>Build a combinational circuit that splits an input half-word (16bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.</p><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">default_nettype</span> none     </span><span class="hljs-comment">// Disable implicit nets. Reduces some types of bugs.</span><br><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] out_hi,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] out_lo );<br>    <span class="hljs-keyword">assign</span> &#123;out_hi, out_lo&#125; = in;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Vector0</title>
    <link href="/2024/08/03/hdlbits-Vector0/"/>
    <url>/2024/08/03/hdlbits-Vector0/</url>
    
    <content type="html"><![CDATA[<h1 id="vector0">Vector0</h1><p>Vectors are used to group related signals using one name to make itmore convenient to manipulate. For example, wire [7:0] w; declares an8-bit vector named w that is functionally equivalent to having 8separate wires.</p><p>Notice that the declaration of a vector places the dimensions beforethe name of the vector, which is unusual compared to C syntax. However,the part select has the dimensions after the vector name as you wouldexpect.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">99</span>:<span class="hljs-number">0</span>] my_vector;      <span class="hljs-comment">// Declare a 100-element vector</span><br><span class="hljs-keyword">assign</span> out = my_vector[<span class="hljs-number">10</span>]; <span class="hljs-comment">// Part-select one bit out of the vector</span><br></code></pre></td></tr></table></figure><p>Build a circuit that has one 3-bit input, then outputs the samevector, and also splits it into three separate 1-bit outputs. Connectoutput o0 to the input vector's position 0, o1 to position 1, etc.</p><p>In a diagram, a tick mark with a number next to it indicates thewidth of the vector (or "bus"), rather than drawing a separate line foreach bit in the vector.</p><figure><img src="/images/Vector0.png" title="Vector0" alt="Vector0" /><figcaption aria-hidden="true">Vector0</figcaption></figure><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module ( <br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] vec,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] outv,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> o2,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> o1,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> o0  ); <span class="hljs-comment">// Module body starts after module declaration</span><br><br>    <span class="hljs-keyword">assign</span> outv = vec;<br>    <span class="hljs-keyword">assign</span> &#123;o2, o1, o0&#125; = vec;<br>    <br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-7458</title>
    <link href="/2024/08/03/hdlbits-7458/"/>
    <url>/2024/08/03/hdlbits-7458/</url>
    
    <content type="html"><![CDATA[<h1 id="section">7458</h1><p>The 7458 is a chip with four AND gates and two OR gates. This problemis slightly more complex than 7420.</p><p>Create a module with the same functionality as the 7458 chip. It has10 inputs and 2 outputs. You may choose to use an assign statement todrive each of the output wires, or you may choose to declare (four)wires for use as intermediate signals, where each internal wire isdriven by the output of one of the AND gates. For extra practice, try itboth ways.</p><figure><img src="/images/7458.png" title="7458" alt="7458" /><figcaption aria-hidden="true">7458</figcaption></figure><blockquote><p>Hint</p></blockquote><blockquote><blockquote><p>You need to drive two signals (p1y and p2y) with a value.</p></blockquote></blockquote><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module ( <br>    <span class="hljs-keyword">input</span> p1a, p1b, p1c, p1d, p1e, p1f,<br>    <span class="hljs-keyword">output</span> p1y,<br>    <span class="hljs-keyword">input</span> p2a, p2b, p2c, p2d,<br>    <span class="hljs-keyword">output</span> p2y );<br><br>    <span class="hljs-keyword">assign</span> p1y = (p1a &amp; p1b &amp; p1c) | ( p1d &amp; p1e &amp; p1f );<br>    <span class="hljs-keyword">assign</span> p2y = (p2a &amp; p2b) | (p2c &amp; p2d);<br><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Declaring-wires</title>
    <link href="/2024/08/03/hdlbits-Declaring-wires/"/>
    <url>/2024/08/03/hdlbits-Declaring-wires/</url>
    
    <content type="html"><![CDATA[<h1 id="declaring-wires">Declaring wires</h1><p>The circuits so far have been simple enough that the outputs aresimple functions of the inputs. As circuits become more complex, youwill need wires to connect internal components together. When you needto use a wire, you should declare it in the body of the module,somewhere before it is first used. (In the future, you will encountermore types of signals and variables that are also declared the same way,but for now, we'll start with a signal of type wire).</p><figure><img src="/images/Wiredecl1.png" title="Wiredecl1" alt="Wiredecl1" /><figcaption aria-hidden="true">Wiredecl1</figcaption></figure><h1 id="example">example</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> in,              <span class="hljs-comment">// Declare an input wire named &quot;in&quot;</span><br>    <span class="hljs-keyword">output</span> out             <span class="hljs-comment">// Declare an output wire named &quot;out&quot;</span><br>);<br><br>    <span class="hljs-keyword">wire</span> not_in;           <span class="hljs-comment">// Declare a wire named &quot;not_in&quot;</span><br><br>    <span class="hljs-keyword">assign</span> out = ~not_in;  <span class="hljs-comment">// Assign a value to out (create a NOT gate).</span><br>    <span class="hljs-keyword">assign</span> not_in = ~in;   <span class="hljs-comment">// Assign a value to not_in (create another NOT gate).</span><br><br><span class="hljs-keyword">endmodule</span>   <span class="hljs-comment">// End of module &quot;top_module&quot;</span><br><br></code></pre></td></tr></table></figure><h1 id="practice">Practice</h1><p>Implement the following circuit. Create two intermediate wires (namedanything you want) to connect the AND and OR gates together. Note thatthe wire that feeds the NOT gate is really wire out, so you do notnecessarily need to declare a third wire here. Notice how wires aredriven by exactly one source (output of a gate), but can feed multipleinputs.</p><p>If you're following the circuit structure in the diagram, you shouldend up with four assign statements, as there are four signals that needa value assigned.</p><figure><img src="/images/Wiredecl2.png" title="Wiredecl2" alt="Wiredecl2" /><figcaption aria-hidden="true">Wiredecl2</figcaption></figure><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">default_nettype</span> none</span><br><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> a,<br>    <span class="hljs-keyword">input</span> b,<br>    <span class="hljs-keyword">input</span> c,<br>    <span class="hljs-keyword">input</span> d,<br>    <span class="hljs-keyword">output</span> out,<br>    <span class="hljs-keyword">output</span> out_n   ); <br><br>    <span class="hljs-keyword">wire</span> p;<br>    <span class="hljs-keyword">assign</span> p = a&amp;b | c&amp;d;<br>    <br>    <span class="hljs-keyword">assign</span> out = p;<br>    <span class="hljs-keyword">assign</span> out_n = ~p;<br>    <br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Xnorgate</title>
    <link href="/2024/08/03/hdlbits-Xnorgate/"/>
    <url>/2024/08/03/hdlbits-Xnorgate/</url>
    
    <content type="html"><![CDATA[<h1 id="xnorgate">Xnorgate</h1><p>Create a module that implements an XNOR gate.</p><figure><img src="/images/Xnorgate.png" title="xnorgate" alt="xnorgate" /><figcaption aria-hidden="true">xnorgate</figcaption></figure><blockquote><p>Hint</p></blockquote><blockquote><blockquote><p>The bitwise-XOR operator is ^. There is no logical-XOR operator.</p></blockquote></blockquote><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> a, <br>    <span class="hljs-keyword">input</span> b, <br>    <span class="hljs-keyword">output</span> out );<br>    <span class="hljs-keyword">assign</span> out = ~(a^b);<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Norgate</title>
    <link href="/2024/08/03/hdlbits-Norgate/"/>
    <url>/2024/08/03/hdlbits-Norgate/</url>
    
    <content type="html"><![CDATA[<h1 id="norgate">Norgate</h1><p>Create a module that implements a NOR gate. A NOR gate is an OR gatewith its output inverted. A NOR function needs two operators whenwritten in Verilog.</p><p>An assign statement drives a wire (or "net", as it's more formallycalled) with a value. This value can be as complex a function as youwant, as long as it's a combinational (i.e., memory-less, with no hiddenstate) function. An assign statement is a continuous assignment becausethe output is "recomputed" whenever any of its inputs change, forever,much like a simple logic gate.</p><figure><img src="/images/Norgate.png" title="norgate" alt="norgate" /><figcaption aria-hidden="true">norgate</figcaption></figure><blockquote><p>Hint</p></blockquote><blockquote><blockquote><p>Verilog has separate bitwise-OR (|) and logical-OR (||) operators,like C. Since we're working with a one-bit here, it doesn't matter whichwe choose.</p></blockquote></blockquote><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> a, <br>    <span class="hljs-keyword">input</span> b, <br>    <span class="hljs-keyword">output</span> out );<br>    <span class="hljs-keyword">assign</span> out = ~(a | b);<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Andgate</title>
    <link href="/2024/08/03/hdlbits-Andgate/"/>
    <url>/2024/08/03/hdlbits-Andgate/</url>
    
    <content type="html"><![CDATA[<h1 id="andgate">Andgate</h1><p>Create a module that implements an AND gate.</p><p>This circuit now has three wires (a, b, and out). Wires a and balready have values driven onto them by the input ports. But wire outcurrently is not driven by anything. Write an assign statement thatdrives out with the AND of signals a and b.</p><p>Note that this circuit is very similar to the NOT gate, just with onemore input. If it sounds different, it's because I've started describingsignals as being driven (has a known value determined by somethingattached to it) or not driven by something. Input wires are driven bysomething outside the module. assign statements will drive a logic levelonto a wire. As you might expect, a wire cannot have more than onedriver (what is its logic level if there is ?), and a wire that has nodrivers will have an undefined value (often treated as 0 whensynthesizing hardware).</p><figure><img src="/images/Andgate.png" title="andgate" alt="andgate" /><figcaption aria-hidden="true">andgate</figcaption></figure><blockquote><p>Hint</p></blockquote><blockquote><blockquote><p>Verilog has separate bitwise-AND (&amp;) and logical-AND (&amp;&amp;)operators, like C. Since we're working with a one-bit here, it doesn'tmatter which we choose.</p></blockquote></blockquote><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> a, <br>    <span class="hljs-keyword">input</span> b, <br>    <span class="hljs-keyword">output</span> out );<br><span class="hljs-keyword">assign</span> out = a&amp;b;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Notgate</title>
    <link href="/2024/08/03/hdlbits-Notgate/"/>
    <url>/2024/08/03/hdlbits-Notgate/</url>
    
    <content type="html"><![CDATA[<h1 id="notgate">Notgate</h1><p>Create a module that implements a NOT gate.</p><p>This circuit is similar to wire, but with a slight difference. Whenmaking the connection from the wire in to the wire out we're going toimplement an inverter (or "NOT-gate") instead of a plain wire.</p><p>Use an assign statement. The assign statement will continuously drivethe inverse of in onto wire out</p><figure><img src="/images/Notgate.png" title="notgate" alt="notgate" /><figcaption aria-hidden="true">notgate</figcaption></figure><blockquote><p>Hint</p></blockquote><blockquote><blockquote><p>Verilog has separate bitwise-NOT (~) and logical-NOT (!) operators,like C. Since we're working with a one-bit here, it doesn't matter whichwe choose.</p></blockquote></blockquote><h1 id="solution">solution</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs veilog">module top_module( input in, output out );<br>assign out = ~in;<br>endmodule<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Wire4</title>
    <link href="/2024/08/03/hdlbits-Wire4/"/>
    <url>/2024/08/03/hdlbits-Wire4/</url>
    
    <content type="html"><![CDATA[<h1 id="wire4">Wire4</h1><p>Create a module with 3 inputs and 4 outputs that behaves like wiresthat makes these connections:</p><p>a -&gt; w b -&gt; x b -&gt; y c -&gt; z</p><p>The diagram below illustrates how each part of the circuitcorresponds to each bit of Verilog code. From outside the module, thereare three input ports and four output ports.</p><p>When you have multiple assign statements, the order in which theyappear in the code does not matter. Unlike a programming language,assign statements ("continuous assignments") describe connectionsbetween things, not the action of copying a value from one thing toanother.</p><p>One potential source of confusion that should perhaps be clarifiednow: The green arrows here represent connections between wires, but arenot wires in themselves. The module itself already has 7 wires declared(named a, b, c, w, x, y, and z). This is because input and outputdeclarations actually declare a wire unless otherwise specified. Writinginput wire a is the same as input a. Thus, the assign statements are notcreating wires, they are creating the connections between the 7 wiresthat already exist.</p><figure><img src="/images/Wire4.png" title="wire4" alt="wire4" /><figcaption aria-hidden="true">wire4</figcaption></figure><blockquote><p>Hint</p></blockquote><blockquote><blockquote><p>The concatenation operator { signal1, signal2, signal3, ... } wouldbe useful here.</p></blockquote></blockquote><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> a,b,c,<br>    <span class="hljs-keyword">output</span> w,x,y,z );<br>    <span class="hljs-keyword">assign</span> &#123;w,x,y,z&#125; = &#123;a,b,b,c&#125;;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><p>or</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br><span class="hljs-keyword">input</span> a,<br><span class="hljs-keyword">input</span> b,<br><span class="hljs-keyword">input</span> c,<br><span class="hljs-keyword">output</span> w,<br><span class="hljs-keyword">output</span> x,<br><span class="hljs-keyword">output</span> y,<br><span class="hljs-keyword">output</span> z  );<br><br><span class="hljs-keyword">assign</span> w = a;<br><span class="hljs-keyword">assign</span> x = b;<br><span class="hljs-keyword">assign</span> y = b;<br><span class="hljs-keyword">assign</span> z = c;<br><br><span class="hljs-comment">// If we&#x27;re certain about the width of each signal, using </span><br><span class="hljs-comment">// the concatenation operator is equivalent and shorter:</span><br><span class="hljs-comment">// assign &#123;w,x,y,z&#125; = &#123;a,b,b,c&#125;;</span><br><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Wire</title>
    <link href="/2024/08/03/hdlbits-Wire/"/>
    <url>/2024/08/03/hdlbits-Wire/</url>
    
    <content type="html"><![CDATA[<h1 id="wire">Wire</h1><p>Create a module with one input and one output that behaves like awire.</p><p>Unlike physical wires, wires (and other signals) in Verilog aredirectional. This means information flows in only one direction, from(usually one) source to the sinks (The source is also often called adriver that drives a value onto a wire). In a Verilog "continuousassignment" (assign left_side = right_side;), the value of the signal onthe right side is driven onto the wire on the left side. The assignmentis "continuous" because the assignment continues all the time even ifthe right side's value changes. A continuous assignment is not aone-time event.</p><p>The ports on a module also have a direction (usually input oroutput). An input port is driven by something from outside the module,while an output port drives something outside. When viewed from insidethe module, an input port is a driver or source, while an output port isa sink.</p><p>The diagram below illustrates how each part of the circuitcorresponds to each bit of Verilog code. The module and portdeclarations create the black portions of the circuit. Your task is tocreate a wire (in green) by adding an assign statement to connect in toout. The parts outside the box are not your concern, but you should knowthat your circuit is tested by connecting signals from our test harnessto the ports on your top_module.</p><figure><img src="/images/Wire.png" title="wire" alt="wire" /><figcaption aria-hidden="true">wire</figcaption></figure><p>In addition to continuous assignments, Verilog has three otherassignment types that are used in procedural blocks, two of which aresynthesizable. We won't be using them until we start using proceduralblocks.</p><blockquote><p>Hint</p></blockquote><blockquote><blockquote><p>A continuous assignment assigns the right side to the left sidecontinuously, so any change to the RHS is immediately seen in theLHS.</p></blockquote></blockquote><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <span class="hljs-keyword">input</span> in, <span class="hljs-keyword">output</span> out );<br><span class="hljs-keyword">assign</span> out = in;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits-Zero</title>
    <link href="/2024/08/03/hdlbits-Zero/"/>
    <url>/2024/08/03/hdlbits-Zero/</url>
    
    <content type="html"><![CDATA[<h1 id="zero">Zero</h1><p>Build a circuit with no inputs and one output that outputs a constant0</p><p>Now that you've worked through the previous problem, let's see if youcan do a simple problem without the hints.</p><blockquote><p>HDLBits uses Verilog-2001 ANSI-style port declaration syntax becauseit's easier to read and reduces typos. You may use the olderVerilog-1995 syntax if you wish. For example, the two moduledeclarations below are acceptable and equivalent:</p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module ( zero );<br>    <span class="hljs-keyword">output</span> zero;<br>    <span class="hljs-comment">// Verilog-1995</span><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module ( <span class="hljs-keyword">output</span> zero ); <br><br>    <span class="hljs-comment">// Verilog-2001</span><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><blockquote><p>Hint</p></blockquote><blockquote><blockquote><p>Fun fact: For Quartus synthesis, not assigning a value to a signalusually results in 0. This problem is actually easier than the previousone.</p></blockquote></blockquote><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">output</span> zero<br>);<span class="hljs-comment">// Module body starts after semicolon</span><br><span class="hljs-keyword">assign</span> zero = <span class="hljs-number">0</span>; <span class="hljs-comment">//写1&#x27;b0更好</span><br><span class="hljs-keyword">endmodule</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdlbits Step one</title>
    <link href="/2024/08/03/hdlbits-Step-one/"/>
    <url>/2024/08/03/hdlbits-Step-one/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>博主在2024-8-1刷完了hdlbits上的所有题目，打算把hdlbits上的自己写的（有些是抄的，打算后面慢慢理解）题解搬运过来做备份。</p><h1 id="step-one">Step one</h1><p>Welcome to HDLBits!</p><p>Getting started in digital logic design can be overwhelming at firstbecause you need to learn new concepts, a new Hardware DescriptionLanguage (e.g., Verilog), several new software packages, and often anFPGA board, all at the same time. HDLBits provides a way to practicedesigning and debugging simple circuits with a single click of"Simulate".</p><p>Designing a circuit requires several steps: Writing HDL (Verilog)code, compiling the code to produce a circuit, then simulating thecircuit and fixing bugs.</p><h1 id="writing-code">Writing Code</h1><p>The easiest way to write your code is to do so in the code editor boxbelow. For this problem, we have filled in most of the code for youalready. Go ahead and finish the code for this circuit.</p><p>Click Simulate to compile and simulate your design.</p><h1 id="compiling-logic-synthesis">Compiling (Logic Synthesis)</h1><p>Your code is compiled using Altera Quartus to produce a circuit.Quartus produces a large number of messages. Click Show Quartus messagesto show/hide them. It's good practice to reduce the number of warnings,but it is sometimes not practical to remove them all.</p><h1 id="simulation">Simulation</h1><p>Your compiled circuit is simulated to test whether it functionscorrectly. HDLBits use ModelSim to simulate your circuit and ourreference solution in parallel, then compares the outputs of themodules. The simulation reports back two things:</p><p>First, it reports whether your circuit matches the reference circuitexactly (zero "mismatches") or how many "mismatches" occurred. Amismatch is the number of samples where the output of your circuit doesnot match the reference output.</p><p>Second, it may produce timing diagrams that show your circuit outputswhen running our test vectors. The simulation waveform is grouped intothree sections: "Inputs", "Yours", and "Ref". In a correct circuit,"Your" outputs will be the same as the "Ref" outputs. The "Mismatch"signals tells you which samples have a mismatch.</p><blockquote><p>The module name and port names of the top-level top_module must notbe changed, or you will get a simulation error.</p></blockquote><h1 id="final-status">Final Status</h1><p>If your circuit was correct, you will see Status: Success!. There area few other possibilities:</p><ol type="1"><li>Compile Error — Circuit did not compile.</li><li>Simulation Error — Circuit compiled successfully, but simulation didnot complete.</li><li>Incorrect — Circuit compiled and simulated, but the outputs did notmatch the reference.</li><li>Success! — Circuit was correct</li></ol><p>You can track or share your progress on the My Stats page.</p><h1 id="problem-statement">Problem Statement</h1><p>We're going to start with a small bit of HDL to get familiar with theinterface used by HDLBits. Here's the description of the circuit youneed to build for this exercise:</p><p>Build a circuit with no inputs and one output. That output shouldalways drive 1 (or logic high).</p><blockquote><p>Module Declaration</p></blockquote><blockquote><blockquote><p>module top_module( output one );</p></blockquote></blockquote><blockquote><p>Hint</p></blockquote><blockquote><blockquote><p>We want to assign 1 to the output one.</p></blockquote></blockquote><h1 id="solution">solution</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <span class="hljs-keyword">output</span> one );<br><br><span class="hljs-keyword">assign</span> one = <span class="hljs-number">1&#x27;b1</span>;<br><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>verilog</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信笔记6</title>
    <link href="/2024/07/22/%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B06/"/>
    <url>/2024/07/22/%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B06/</url>
    
    <content type="html"><![CDATA[<h1 id="数字频带传输系统">数字频带传输系统</h1><h2 id="前言">前言</h2><p>《通信原理（第七版）》中的“数字基带传输系统”内容博主略过了，因为用不到[doge]</p><h2 id="数字调制">数字调制</h2><p>把数字基带信号变换为数字带通信号（已调信号）的过程称为数字调制（digitalmodulation）。</p><p>通常把包括调制和解调过程的数字传输系统叫做数字带通传输系统。</p><p>数字调制技术分两种</p><ol type="1"><li>模拟调制，把数字信号看成模拟调制的一个特例。</li><li>键控法，利用数字信号的离散取值特点通过开关键控载波</li></ol><p>键控法调制分类</p><ul><li>振幅键控（ASK）</li><li>频移键控（FSK）</li><li>相移键控（PSK）</li></ul><p>数字信息有二进制和多进制之分，因此数字调制可分为二进制调制和多进制调制。</p><h2 id="二进制数字调制">二进制数字调制</h2><h3 id="二进制振幅键控2ask">二进制振幅键控(2ASK)</h3><p>载波幅度只有两种变化状态，频率相位不变。</p><p>通断键控(OOK)</p><p><span class="math display">\[e_{OOK}(t) = \left\{\begin{aligned}    &amp;A\cos w_c t ~~~~ 以概率P发送1 \\    &amp;0 ~~~~ 以概率1-P发送0\end{aligned}\right.\]</span></p><p>2ASK信号一般表达式 <span class="math display">\[e_{2ASK} (t) = s(t)\cos w_c t\]</span> <span class="math display">\[s(t) = \sum_n a_n g(t - nT_B)\]</span> 式中<spanclass="math inline">\(T_B\)</span>为码元持续时间；<spanclass="math inline">\(g(t)\)</span>为持续时间为<spanclass="math inline">\(T_B\)</span>的基带脉冲波形。通常假设<spanclass="math inline">\(g(t)\)</span>是高度为1宽度等于<spanclass="math inline">\(T_B\)</span>的矩形脉冲；<spanclass="math inline">\(a_n\)</span>是第<spanclass="math inline">\(n\)</span>个符号的电平取值。 若取 <spanclass="math display">\[a_n = \left\{\begin{aligned}    &amp;1 ~~~~ 概率为P \\    &amp;0 ~~~~ 概率为1-P\end{aligned}\right.\]</span> 则相应2ASK信号就是OOK信号。</p><figure><img src="/images/2ASK波形.png" title="2ASK波形"alt="2ASK波形https://www.bilibili.com/video/BV1wA4y1f7Co?p=37" /><figcaptionaria-hidden="true">2ASK波形https://www.bilibili.com/video/BV1wA4y1f7Co?p=37</figcaption></figure><h4 id="askook信号产生方法">2ASK/OOK信号产生方法</h4><p>模拟调制法</p><figure><img src="/images/模拟2ASK.png" title="模拟2ASK"alt="模拟2ASKhttps://www.bilibili.com/video/BV1wA4y1f7Co?p=37" /><figcaptionaria-hidden="true">模拟2ASKhttps://www.bilibili.com/video/BV1wA4y1f7Co?p=37</figcaption></figure><p>键控法</p><figure><img src="/images/键控2ASK.png" title="键控2ASK"alt="键控2ASKhttps://www.bilibili.com/video/BV1wA4y1f7Co?p=37" /><figcaptionaria-hidden="true">键控2ASKhttps://www.bilibili.com/video/BV1wA4y1f7Co?p=37</figcaption></figure><h4 id="askook信号解调方法">2ASK/OOK信号解调方法</h4><p>非相干（noncoherent）解调（包络检波法）</p><figure><img src="/images/包络2ASK解调.png" title="包络2ASK解调"alt="包络2ASK解调https://www.bilibili.com/video/BV1wA4y1f7Co?p=37" /><figcaptionaria-hidden="true">包络2ASK解调https://www.bilibili.com/video/BV1wA4y1f7Co?p=37</figcaption></figure><p>相干（coherent）解调（同步检测法）</p><figure><img src="/images/相干2ASK解调.png" title="相干2ASK解调"alt="相干2ASK解调https://www.bilibili.com/video/BV1wA4y1f7Co?p=37" /><figcaptionaria-hidden="true">相干2ASK解调https://www.bilibili.com/video/BV1wA4y1f7Co?p=37</figcaption></figure><h4 id="ask功率谱密度">2ASK功率谱密度</h4><p>由于2ASK信号是随机的功率信号，故研究它的频谱特性时，应该讨论它的功率谱密度。</p><p>2ASK信号可以表示成 <span class="math display">\[e_{2ASK} (t) = s(t)\cos w_c t\]</span> 式中<spanclass="math inline">\(s(t)\)</span>为随机的单极性（single-polarity）二进制基带脉冲序列</p><p>2ASK功率谱密度表达式 <span class="math display">\[P_{2ASK}(f) = \frac{1}{4} [P(f+ f_c) + P(f - f_c)]\]</span></p><p>可见<spanclass="math inline">\(P_{2ASK}(f)\)</span>是单极性基带信号功率谱<spanclass="math inline">\(P_s(f)\)</span>的线性搬移</p><figure><img src="/images/2ASK功率谱.jpg" title="2ASK功率谱" alt="2ASK功率谱" /><figcaption aria-hidden="true">2ASK功率谱</figcaption></figure><p>从图中可以看出，</p><ul><li>2ASK信号的功率谱由连续谱和离散谱两部分组成，连续谱取决于<spanclass="math inline">\(g(t)\)</span>经线性调制后的双边带谱，而离散谱由载波分量确定。</li><li>2ASK信号的带宽<spanclass="math inline">\(B_{2ASK}\)</span>是基带信号带宽的两倍，若只记谱的主瓣（mainlobe）（第一个谱零点位置），则有 <span class="math display">\[B_{2ASK} = 2f_B\]</span> 其中<span class="math inline">\(f_B = 1/T_B =R_B\)</span>（码元速率）</li></ul><p>可见2ASK信号传输带宽是码元速率的2倍</p><h3 id="二进制频移键控2fsk">二进制频移键控(2FSK)</h3><p>在2FSK中，载波的频率随二进制基带信号在<spanclass="math inline">\(f_1\)</span>和<spanclass="math inline">\(f_2\)</span>之间变化</p><p>表达式为 <span class="math display">\[e_{2FSK} (t) = \left\{\begin{aligned}    &amp;A\cos(w_1 t + \phi_n) ~~~~ 发送1时 \\    &amp;A\cos(w_2 t + \theta_n) ~~~~ 发送0时\end{aligned}\right.\]</span></p><p>2FSK信号可以看成两个不同的2ASK信号叠加，2FSK时域表达式又可以写成<span class="math display">\[e_{2FSK} (t) = s_1(t)A\cos(w_1 t + \phi_n) + s_2(t)A\cos(w_2 t +\theta_n) \tag{1}\]</span> 式中<span class="math inline">\(s_1(t)\)</span>和<spanclass="math inline">\(s_2(t)\)</span>都是单极性脉冲序列，两个信号极性相反。<spanclass="math inline">\(\phi_n\)</span>和<spanclass="math inline">\(\theta_n\)</span>不携带信息，通常取0。于是式（1）化简为<span class="math display">\[e_{2FSK} (t) = s_1(t)A\cos(w_1 t) + s_2(t)A\cos(w_2 t) \tag{2}\]</span></p><figure><img src="/images/2FSK波形.png" title="2FSK波形"alt="2FSK波形https://www.bilibili.com/video/BV1wA4y1f7Co?p=37" /><figcaptionaria-hidden="true">2FSK波形https://www.bilibili.com/video/BV1wA4y1f7Co?p=37</figcaption></figure><h4 id="fsk信号产生方法">2FSK信号产生方法</h4><p>第一种方法是采用模拟调频电路</p><p>第二种方法是键控法</p><figure><img src="/images/键控法2FSK.png" title="键控法2FSK"alt="键控法2FSKhttps://www.bilibili.com/video/BV1wA4y1f7Co?p=37" /><figcaptionaria-hidden="true">键控法2FSKhttps://www.bilibili.com/video/BV1wA4y1f7Co?p=37</figcaption></figure><h4 id="fsk信号解调方法">2FSK信号解调方法</h4><p>非相干解调（包络检波）</p><figure><img src="/images/包络解调2FSK.png" title="包络解调2FSK"alt="包络解调2FSKhttps://www.bilibili.com/video/BV1wA4y1f7Co?p=37" /><figcaptionaria-hidden="true">包络解调2FSKhttps://www.bilibili.com/video/BV1wA4y1f7Co?p=37</figcaption></figure><p>相干解调</p><figure><img src="/images/相干解调2FSK.png" title="相干解调2FSK"alt="相干解调2FSKhttps://www.bilibili.com/video/BV1wA4y1f7Co?p=37" /><figcaptionaria-hidden="true">相干解调2FSKhttps://www.bilibili.com/video/BV1wA4y1f7Co?p=37</figcaption></figure><p>其它方法</p><figure><img src="/images/其它方法解调2FSK.png" title="其它方法解调2FSK"alt="其它方法解调2FSKhttps://www.bilibili.com/video/BV1wA4y1f7Co?p=37" /><figcaptionaria-hidden="true">其它方法解调2FSKhttps://www.bilibili.com/video/BV1wA4y1f7Co?p=37</figcaption></figure><h4 id="fsk功率谱密度">2FSK功率谱密度</h4><p>相位不连续的2FSK信号可以看成是两个不同载频的2ASK信号叠加。因此2FSK的功率谱可以近似表示成中心频率分别为<spanclass="math inline">\(f_1\)</span>和<spanclass="math inline">\(f_2\)</span>的两个2ASK功率谱组合 <spanclass="math display">\[P_{2FSK}(f) = \frac{1}{4} [P_{s1}(f - f_1) + P_{s1}(f + f_1)] +\frac{1}{4} [P_{s2}(f - f_2) + P_{s2}(f + f_2)]\]</span> 其曲线如图</p><figure><img src="/images/2FSK功率谱.jpg" title="2FSK功率谱" alt="2FSK功率谱" /><figcaption aria-hidden="true">2FSK功率谱</figcaption></figure><h3 id="二进制相移键控2psk">二进制相移键控(2PSK)</h3><p>利用载波的相移变化来传递数字信息，振幅频率保持不变</p><p>时域表达式 <span class="math display">\[e_{2PSK}(t) = A\cos (w_c t + \phi_n) \tag{3}\]</span> 式中<spanclass="math inline">\(\phi_n\)</span>表示第n个符号的绝对相位 <spanclass="math display">\[\phi_n = \left\{\begin{aligned}    &amp;0 ~~~~ 发送0时 \\    &amp;\pi ~~~~ 发送1时\end{aligned}\right.\]</span> 式（3）可以改写为 <span class="math display">\[\phi_n = \left\{\begin{aligned}    &amp;A\cos (w_c t) ~~~~ 概率为P \\    &amp;-A\cos (w_c t) ~~~~ 概率为1-P\end{aligned}\right.\tag{4}\]</span></p><figure><img src="/images/2PSK波形.png" title="2PSK波形"alt="2PSK波形https://www.bilibili.com/video/BV1wA4y1f7Co?p=38" /><figcaptionaria-hidden="true">2PSK波形https://www.bilibili.com/video/BV1wA4y1f7Co?p=38</figcaption></figure><p>由于表示2PSK信号的两种码元的波形相同，极性相反，故2PSK信号一般可以表述为一个双极性（bipolarity）全占空（100%duty ratio）矩形脉冲序列与一个正弦波的相乘 <span class="math display">\[e_{2PSK}(t) = s(t)\cos w_c t\]</span> <span class="math display">\[s(t) = \sum_n a_n g(t-nT_B)\]</span> 这里<span class="math inline">\(g(t)\)</span>为脉宽为<spanclass="math inline">\(T_B\)</span>的单个矩形脉冲；<spanclass="math inline">\(a_n\)</span>的统计特性为 <spanclass="math display">\[a_n = \left\{\begin{aligned}    &amp;1 ~~~~ 概率为P \\    &amp;-1 ~~~~ 概率为1-P\end{aligned}\right.\]</span></p><p>以载波的不同相位直接表示相应二进制数字信号的调制方式，称为<strong>绝对相移方式</strong></p><h4 id="psk信号产生方法">2PSK信号产生方法</h4><figure><img src="/images/2PSK调制.png" title="2PSK调制"alt="2PSK调制https://www.bilibili.com/video/BV1wA4y1f7Co?p=38" /><figcaptionaria-hidden="true">2PSK调制https://www.bilibili.com/video/BV1wA4y1f7Co?p=38</figcaption></figure><h4 id="psk信号解调方法">2PSK信号解调方法</h4><figure><img src="/images/2PSK解调1.png" title="2PSK解调1"alt="2PSK解调1https://www.bilibili.com/video/BV1wA4y1f7Co?p=38" /><figcaptionaria-hidden="true">2PSK解调1https://www.bilibili.com/video/BV1wA4y1f7Co?p=38</figcaption></figure><figure><img src="/images/2PSK解调2.png" title="2PSK解调2"alt="2PSK解调2https://www.bilibili.com/video/BV1wA4y1f7Co?p=38" /><figcaptionaria-hidden="true">2PSK解调2https://www.bilibili.com/video/BV1wA4y1f7Co?p=38</figcaption></figure><figure><img src="/images/2PSK解调3.png" title="2PSK解调3"alt="2PSK解调3https://www.bilibili.com/video/BV1wA4y1f7Co?p=38" /><figcaptionaria-hidden="true">2PSK解调3https://www.bilibili.com/video/BV1wA4y1f7Co?p=38</figcaption></figure><figure><img src="/images/2PSK解调4.png" title="2PSK解调4"alt="2PSK解调4https://www.bilibili.com/video/BV1wA4y1f7Co?p=38" /><figcaptionaria-hidden="true">2PSK解调4https://www.bilibili.com/video/BV1wA4y1f7Co?p=38</figcaption></figure><h4 id="dpsk信号产生方法">2DPSK信号产生方法</h4><figure><img src="/images/2DPSK信号产生方法.png" title="2DPSK信号产生方法"alt="2DPSK信号产生方法https://www.bilibili.com/video/BV1wA4y1f7Co?p=38" /><figcaptionaria-hidden="true">2DPSK信号产生方法https://www.bilibili.com/video/BV1wA4y1f7Co?p=38</figcaption></figure><h4 id="dpsk信号解调">2DPSK信号解调</h4><figure><img src="/images/2DPSK信号解调.png" title="2DPSK信号解调"alt="2DPSK信号解调https://www.bilibili.com/video/BV1wA4y1f7Co?p=38" /><figcaptionaria-hidden="true">2DPSK信号解调https://www.bilibili.com/video/BV1wA4y1f7Co?p=38</figcaption></figure><figure><img src="/images/2DPSK信号解调2.png" title="2DPSK信号解调2"alt="2DPSK信号解调2https://www.bilibili.com/video/BV1wA4y1f7Co?p=38" /><figcaptionaria-hidden="true">2DPSK信号解调2https://www.bilibili.com/video/BV1wA4y1f7Co?p=38</figcaption></figure><h4 id="psk2dpsk功率谱密度">2PSK/2DPSK功率谱密度</h4><p><span class="math display">\[P_{2PSK}(f) = \frac{1}{4} [ P_s(f + f_c) + P_s(f - f_c) ]\]</span> <spanclass="math inline">\(P_s(f)\)</span>是双极性的随机矩形脉冲序列的功率谱</p><p><span class="math display">\[P_{2PSK}(f) = \frac{T_B}{4} \left[ \left| \frac{ \sin \pi (f + f_c)T_B}{ \pi (f+f_c)T_B } \right|^2 + \left| \frac{ \sin \pi (f - f_c)T_B }{\pi (f-f_c)T_B } \right|^2 \right]\]</span></p><p>2DPSK的功率谱密度和2PSK的功率谱密度是一样的。</p><figure><img src="/images/2PSK-2DPSK信号功率谱密度.png"title="2PSK-2DPSK信号功率谱密度"alt="2PSK-2DPSK信号功率谱密度https://www.bilibili.com/video/BV1wA4y1f7Co?p=39" /><figcaptionaria-hidden="true">2PSK-2DPSK信号功率谱密度https://www.bilibili.com/video/BV1wA4y1f7Co?p=39</figcaption></figure><p>可见2PSK/2DPSK带宽是基带信号的2倍。当<spanclass="math inline">\(P=1/2\)</span>时，谱中无离散谱（即载波分量）。2PSK信号相当于抑制载波的双边带信号，因此它可以看作是双极性基带信号作用下的调幅信号。</p><h2 id="二进制数字调制系统抗噪声性能">二进制数字调制系统抗噪声性能</h2><p>分析数字系统的抗噪声性能就是求系统在信道噪声干扰下的总误码率。</p><p>性能指标：系统误码率<span class="math inline">\(P_e\)</span></p><p>分析条件</p><ul><li>信道特性是恒参信道，在信道的频带范围内有理想矩形的传输特性（可取其传输系数为<spanclass="math inline">\(K\)</span>）</li><li>信道噪声是加性高斯白噪声。噪声只对接收有影响。分析系统性能是在接收端进行的</li></ul><h3 id="ask抗噪声性能">2ASK抗噪声性能</h3><figure><img src="/images/2ASK误码率推导.png" title="2ASK误码率推导"alt="2ASK误码率推导https://www.bilibili.com/video/BV1wA4y1f7Co?p=40" /><figcaptionaria-hidden="true">2ASK误码率推导https://www.bilibili.com/video/BV1wA4y1f7Co?p=40</figcaption></figure><figure><img src="/images/2ASK误码率推导2.png" title="2ASK误码率推导2"alt="2ASK误码率推导2https://www.bilibili.com/video/BV1wA4y1f7Co?p=40" /><figcaptionaria-hidden="true">2ASK误码率推导2https://www.bilibili.com/video/BV1wA4y1f7Co?p=40</figcaption></figure><figure><img src="/images/2ASK误码率推导3.png" title="2ASK误码率推导3"alt="2ASK误码率推导3https://www.bilibili.com/video/BV1wA4y1f7Co?p=40" /><figcaptionaria-hidden="true">2ASK误码率推导3https://www.bilibili.com/video/BV1wA4y1f7Co?p=40</figcaption></figure><figure><img src="/images/2ASK误码率推导4.png" title="2ASK误码率推导4"alt="2ASK误码率推导4https://www.bilibili.com/video/BV1wA4y1f7Co?p=40" /><figcaptionaria-hidden="true">2ASK误码率推导4https://www.bilibili.com/video/BV1wA4y1f7Co?p=40</figcaption></figure><p><span class="math display">\[P(0/1) = P(x \leq b) = \int_{-\infty}^b f_1(x)dx = 1 - \frac{1}{2}erfc(\frac{ b-a }{\sqrt{2} \sigma_n})\]</span> <span class="math display">\[erfc(x) = \frac{2}{\sqrt{\pi}} \int_{x}^{\infty} e^{-u^2}du\]</span></p><figure><img src="/images/2ASK包络检波误码率1.png" title="2ASK包络检波误码率1"alt="2ASK包络检波误码率1https://www.bilibili.com/video/BV1wA4y1f7Co?p=40" /><figcaptionaria-hidden="true">2ASK包络检波误码率1https://www.bilibili.com/video/BV1wA4y1f7Co?p=40</figcaption></figure><figure><img src="/images/2ASK包络检波误码率2.png" title="2ASK包络检波误码率2"alt="2ASK包络检波误码率2https://www.bilibili.com/video/BV1wA4y1f7Co?p=40" /><figcaptionaria-hidden="true">2ASK包络检波误码率2https://www.bilibili.com/video/BV1wA4y1f7Co?p=40</figcaption></figure><figure><img src="/images/2ASK包络检波误码率3.png" title="2ASK包络检波误码率3"alt="2ASK包络检波误码率3https://www.bilibili.com/video/BV1wA4y1f7Co?p=40" /><figcaptionaria-hidden="true">2ASK包络检波误码率3https://www.bilibili.com/video/BV1wA4y1f7Co?p=40</figcaption></figure><h3 id="fsk抗噪声性能">2FSK抗噪声性能</h3><figure><img src="/images/2FSK相干解调误码率1.png" title="2FSK相干解调误码率1"alt="2FSK相干解调误码率1https://www.bilibili.com/video/BV1wA4y1f7Co?p=40" /><figcaptionaria-hidden="true">2FSK相干解调误码率1https://www.bilibili.com/video/BV1wA4y1f7Co?p=40</figcaption></figure><figure><img src="/images/2FSK相干解调误码率2.png" title="2FSK相干解调误码率2"alt="2FSK相干解调误码率2https://www.bilibili.com/video/BV1wA4y1f7Co?p=40" /><figcaptionaria-hidden="true">2FSK相干解调误码率2https://www.bilibili.com/video/BV1wA4y1f7Co?p=40</figcaption></figure><figure><img src="/images/2FSK相干解调误码率3.png" title="2FSK相干解调误码率3"alt="2FSK相干解调误码率3https://www.bilibili.com/video/BV1wA4y1f7Co?p=40" /><figcaptionaria-hidden="true">2FSK相干解调误码率3https://www.bilibili.com/video/BV1wA4y1f7Co?p=40</figcaption></figure><figure><img src="/images/2FSK包络检波误码率1.png" title="2FSK包络检波误码率1"alt="2FSK包络检波误码率1https://www.bilibili.com/video/BV1wA4y1f7Co?p=40" /><figcaptionaria-hidden="true">2FSK包络检波误码率1https://www.bilibili.com/video/BV1wA4y1f7Co?p=40</figcaption></figure><figure><img src="/images/2FSK包络检波误码率2.png" title="2FSK包络检波误码率2"alt="2FSK包络检波误码率2https://www.bilibili.com/video/BV1wA4y1f7Co?p=40" /><figcaptionaria-hidden="true">2FSK包络检波误码率2https://www.bilibili.com/video/BV1wA4y1f7Co?p=40</figcaption></figure><h3 id="psk抗噪声性能">2PSK抗噪声性能</h3><figure><img src="/images/2PSK相干解调误码率1.png" title="2PSK相干解调误码率1"alt="2PSK相干解调误码率1https://www.bilibili.com/video/BV1wA4y1f7Co?p=41" /><figcaptionaria-hidden="true">2PSK相干解调误码率1https://www.bilibili.com/video/BV1wA4y1f7Co?p=41</figcaption></figure><figure><img src="/images/2PSK相干解调误码率2.png" title="2PSK相干解调误码率2"alt="2PSK相干解调误码率2https://www.bilibili.com/video/BV1wA4y1f7Co?p=41" /><figcaptionaria-hidden="true">2PSK相干解调误码率2https://www.bilibili.com/video/BV1wA4y1f7Co?p=41</figcaption></figure><figure><img src="/images/2PSK相干解调误码率3.png" title="2PSK相干解调误码率3"alt="2PSK相干解调误码率3https://www.bilibili.com/video/BV1wA4y1f7Co?p=41" /><figcaptionaria-hidden="true">2PSK相干解调误码率3https://www.bilibili.com/video/BV1wA4y1f7Co?p=41</figcaption></figure><figure><img src="/images/2PSK相干解调误码率4.png" title="2PSK相干解调误码率4"alt="2PSK相干解调误码率4https://www.bilibili.com/video/BV1wA4y1f7Co?p=41" /><figcaptionaria-hidden="true">2PSK相干解调误码率4https://www.bilibili.com/video/BV1wA4y1f7Co?p=41</figcaption></figure><figure><img src="/images/2DPSK误码率1.png" title="2DPSK误码率1"alt="2DPSK误码率1https://www.bilibili.com/video/BV1wA4y1f7Co?p=41" /><figcaptionaria-hidden="true">2DPSK误码率1https://www.bilibili.com/video/BV1wA4y1f7Co?p=41</figcaption></figure><figure><img src="/images/2DPSK误码率2.png" title="2DPSK误码率2"alt="2DPSK误码率2https://www.bilibili.com/video/BV1wA4y1f7Co?p=41" /><figcaptionaria-hidden="true">2DPSK误码率2https://www.bilibili.com/video/BV1wA4y1f7Co?p=41</figcaption></figure><figure><img src="/images/2DPSK误码率3.png" title="2DPSK误码率3"alt="2DPSK误码率3https://www.bilibili.com/video/BV1wA4y1f7Co?p=41" /><figcaptionaria-hidden="true">2DPSK误码率3https://www.bilibili.com/video/BV1wA4y1f7Co?p=41</figcaption></figure><figure><img src="/images/2DPSK误码率4.png" title="2DPSK误码率4"alt="2DPSK误码率4https://www.bilibili.com/video/BV1wA4y1f7Co?p=41" /><figcaptionaria-hidden="true">2DPSK误码率4https://www.bilibili.com/video/BV1wA4y1f7Co?p=41</figcaption></figure><h3 id="抗噪声性能总结">抗噪声性能总结</h3><figure><img src="/images/抗噪声性能总结1.png" title="抗噪声性能总结1"alt="抗噪声性能总结1https://www.bilibili.com/video/BV1wA4y1f7Co?p=42" /><figcaptionaria-hidden="true">抗噪声性能总结1https://www.bilibili.com/video/BV1wA4y1f7Co?p=42</figcaption></figure><figure><img src="/images/抗噪声性能总结2.png" title="抗噪声性能总结2"alt="抗噪声性能总结2https://www.bilibili.com/video/BV1wA4y1f7Co?p=42" /><figcaptionaria-hidden="true">抗噪声性能总结2https://www.bilibili.com/video/BV1wA4y1f7Co?p=42</figcaption></figure><figure><img src="/images/抗噪声性能总结3.png" title="抗噪声性能总结3"alt="抗噪声性能总结3https://www.bilibili.com/video/BV1wA4y1f7Co?p=42" /><figcaptionaria-hidden="true">抗噪声性能总结3https://www.bilibili.com/video/BV1wA4y1f7Co?p=42</figcaption></figure><figure><img src="/images/抗噪声性能总结4.png" title="抗噪声性能总结4"alt="抗噪声性能总结4https://www.bilibili.com/video/BV1wA4y1f7Co?p=42" /><figcaptionaria-hidden="true">抗噪声性能总结4https://www.bilibili.com/video/BV1wA4y1f7Co?p=42</figcaption></figure><figure><img src="/images/抗噪声性能总结5.png" title="抗噪声性能总结5"alt="抗噪声性能总结5https://www.bilibili.com/video/BV1wA4y1f7Co?p=42" /><figcaptionaria-hidden="true">抗噪声性能总结5https://www.bilibili.com/video/BV1wA4y1f7Co?p=42</figcaption></figure><h1 id="通信笔记小结">通信笔记小结</h1><p>先学到这，后面的内容用到再学。博主学这个不用考试，主打一个囫囵吞枣。</p>]]></content>
    
    
    <categories>
      
      <category>通信原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信笔记5</title>
    <link href="/2024/07/18/%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B05/"/>
    <url>/2024/07/18/%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B05/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟调制与解调">模拟调制与解调</h1><p>调制：把消息信号寄托在载波的某个参数上，形成已调信号。</p><p>解调：调制的逆过程，从已调信号中恢复消息信号。</p><p>调制目的：</p><ul><li>匹配信道特性，减小天线尺寸，提高辐射效率</li><li>通过频谱搬移，实现信道的多路复用，提高信道利用率</li><li>拓展信号带宽，提高抗干扰能力</li><li>实现带宽与信噪比的互换</li></ul><p>调制分类</p><figure><img src="/images/调制分类.png" title="调制分类"alt="调制分类https://www.bilibili.com/video/BV1wA4y1f7Co?p=18" /><figcaptionaria-hidden="true">调制分类https://www.bilibili.com/video/BV1wA4y1f7Co?p=18</figcaption></figure><figure><img src="/images/调制分类2.png" title="调制分类"alt="调制分类https://www.bilibili.com/video/BV1wA4y1f7Co?p=18" /><figcaptionaria-hidden="true">调制分类https://www.bilibili.com/video/BV1wA4y1f7Co?p=18</figcaption></figure><h2 id="线性调制">线性调制</h2><h3 id="调幅am">调幅AM</h3><p>AM调制原理图</p><figure><img src="/images/AM调制原理图.png" title="AM调制原理图"alt="AM调制原理图https://www.bilibili.com/video/BV1wA4y1f7Co?p=19" /><figcaptionaria-hidden="true">AM调制原理图https://www.bilibili.com/video/BV1wA4y1f7Co?p=19</figcaption></figure><p>其中<span class="math inline">\(m(t)\)</span>均值为0，且直流偏置<spanclass="math inline">\(A_0 \geq |m(t)|_{max}\)</span></p><p>AM调幅系数： <span class="math display">\[a = \frac{ |m(t)|_{max} }{ A_0 }\]</span></p><p>当调制系数小于等于1时，包络和<spanclass="math inline">\(m(1)\)</span>成正比，可以用包络检波进行解调。当调制系数大于1时，调制信号会出现载波反向点，包络和<spanclass="math inline">\(m(1)\)</span>不成正比。</p><p>调制信号的时域表达式</p><p><span class="math display">\[s_{AM}(t) = [A_0 + m(t)] \cos w_c t = A_0 \cos w_c t + m(t) \cos w_c t\]</span></p><p><span class="math inline">\(A_0 \cos w_c t\)</span>为载波项，<spanclass="math inline">\(m(t) \cos w_c t\)</span>为边带项</p><p>频域表达式</p><p><span class="math display">\[S_{AM}(w) = \pi A_0 [ \delta(w + w_c) + \delta (w - w_c)] + \frac{1}{2}[ M(w+w_c) + M(w - w_c) ]\]</span></p><p>其中<span class="math inline">\(\pi A_0 [ \delta(w + w_c) + \delta (w- w_c)]\)</span>是载波项，<span class="math inline">\(\frac{1}{2} [M(w+w_c) + M(w - w_c) ]\)</span>是边带项</p><p>调制信号的频谱图</p><figure><img src="/images/AM调制频谱图.png" title="AM调制频谱图"alt="AM调制频谱图https://www.bilibili.com/video/BV1wA4y1f7Co?p=19" /><figcaptionaria-hidden="true">AM调制频谱图https://www.bilibili.com/video/BV1wA4y1f7Co?p=19</figcaption></figure><p>因为调制信号包含了上下两条正比于m(t)的边带（调制系数<spanclass="math inline">\(a\)</span>小于等于1），所以频谱中的带宽是两倍的m(t)带宽。</p><p>AM信号在<spanclass="math inline">\(1\Omega\)</span>电阻上的平均功率等于<spanclass="math inline">\(s_{AM}(t)\)</span>的均方值 <spanclass="math display">\[P_{AM} = \overline{ s_{AM}^2 (t) } = \overline{ [A_0 + m(t)]^2 \cos^2w_c t } = \overline{ A_0^2 \cos^2 w_c t } + \overline{ m^2(t) \cos^2 w_ct } + \overline{ 2A_0 m(t) \cos^2 w_c t }\]</span></p><p>因为<span class="math inline">\(m(t)\)</span>的均值为0，所以<spanclass="math inline">\(\overline{ m(t) } = 0\)</span></p><p><span class="math display">\[P_{AM} = \frac{ A_0^2 }{2} + \frac{ \overline{ m^2(t) } }{ 2 } = P_c +P_s\]</span></p><p><span class="math inline">\(P_c\)</span>为载波功率，<spanclass="math inline">\(P_s\)</span>为边带功率</p><p>调制效率<span class="math inline">\(\eta_{AM}\)</span> =有用功率（用于传输信息的边带功率） / 信号总功率</p><p><span class="math display">\[\eta_{AM} = \frac{ P_s }{ P_{AM} }\]</span></p><p>AM调制优缺点：</p><ul><li>优点<ul><li>系统结构简单，价格低廉</li></ul></li><li>缺点<ul><li>功率利用率比较低（调制信号为单音余弦信号，<spanclass="math inline">\(a = 1\)</span>时“满调幅”，<spanclass="math inline">\(\eta_{AM}\)</span>最大为<spanclass="math inline">\(1/3\)</span>）</li></ul></li></ul><h4 id="包络检波">包络检波</h4><figure><img src="/images/包络检波.png" title="包络检波"alt="包络检波https://www.bilibili.com/video/BV1wA4y1f7Co?p=21" /><figcaptionaria-hidden="true">包络检波https://www.bilibili.com/video/BV1wA4y1f7Co?p=21</figcaption></figure><h3 id="双边带调制">双边带调制</h3><p>在AM调制模型中将<spanclass="math inline">\(A_0\)</span>去掉，即可得到一种高调制效率的调制方式——抑制载波双边带信号（DSB-SC），简称双边带信号。<span class="math display">\[s_{DSB}(t) = m(t) \cos w_c t\]</span> 同样假设<span class="math inline">\(m(t)\)</span>均值为0</p><p>DSB的频谱和AM频谱相近，只是没有了在<span class="math inline">\(\pmw_c\)</span>处的<span class="math inline">\(\delta\)</span>函数。 <spanclass="math display">\[S_{DSB}(w) = \frac{1}{2} [M(w + w_c) + M(w - w_c)]\]</span></p><figure><img src="/images/DSB信号.jpg" title="DSB信号" alt="DSB信号" /><figcaption aria-hidden="true">DSB信号</figcaption></figure><p>显然，DSB信号不存在载波分量，所以调制效率是100%。但是DSB无法用包络检波恢复调制信号。解调方法是相干解调，也称同步检测。</p><p>DSB需要的传输带宽仍然是调制信号的两倍，即与AM信号带宽相同</p><h3 id="单边带调制">单边带调制</h3><p>注意到DSB信号的两个边带中任意一个都包含<spanclass="math inline">\(M(w)\)</span>的所有频谱成分，因此只传输一个边带即可。这样能节省发送功率和1/2传输频带。</p><p>单边带调制（SSB）信号是将双边带信号中的一个边带滤掉而形成的。根据滤除方法，可以分为滤波法和相移法。</p><h4 id="滤波法ssb信号">滤波法SSB信号</h4><p>使用高通或低通滤波器<spanclass="math inline">\(H(w)\)</span>得到SSB信号。高通对应上边带，低通对应下边带。<span class="math display">\[S_{SSB}(w) = S_{DSB}(w) \cdot H(w)\]</span> 如图</p><figure><img src="/images/滤波法SSB.jpg" title="滤波法SSB" alt="滤波法SSB" /><figcaption aria-hidden="true">滤波法SSB</figcaption></figure><p>假如语音信号的最低频率为300Hz，则上下边带之间的频率间隔为600Hz，即允许过渡带为600Hz。实现滤波器的难易程度与过渡带相对载频的归一化值有关。值越小，边带滤波器就越难实现。</p><h4 id="相移法ssb信号">相移法SSB信号</h4><p>需要借助希尔伯特变换描述SSB信号的时域表达式。</p><p>设单频调制信号 <span class="math display">\[m(t) = A_m\cos w_m t\]</span> 载波为 <span class="math display">\[c(t) = \cos w_c t\]</span> DSB信号的时域表达式 <span class="math display">\[\begin{aligned}s_{DSB}(t) &amp;= A_m \cos w_m t \cos w_c t \\&amp;= \frac{1}{2} A_m\cos (w_c + w_m)t + \frac{1}{2} A_m\cos (w_c -w_m)t\end{aligned}\]</span></p><p>上边带是<span class="math inline">\(\frac{1}{2} A_m\cos (w_c + w_m)t= \frac{1}{2} A_m\cos w_m t\cos w_c t - \frac{1}{2} A_m \sin w_m t \sinw_c t\)</span></p><p>下边带是<span class="math inline">\(\frac{1}{2} A_m\cos (w_c - w_m)t= \frac{1}{2} A_m\cos w_m t\cos w_c t + \frac{1}{2} A_m \sin w_m t \sinw_c t\)</span></p><p>上下边带合并得到<span class="math inline">\(s_{SSB}(t)\)</span> <spanclass="math display">\[s_{SSB}(t) = \frac{1}{2} A_m\cos w_m t\cos w_c t \mp \frac{1}{2} A_m\sin w_m t \sin w_c t \tag{1}\]</span></p><p>式中<span class="math inline">\(A_m \sin w_m t\)</span>可以看成<spanclass="math inline">\(A_m\cos w_m t\)</span>相移<spanclass="math inline">\(\frac{\pi}{2}\)</span>的结果。把这一过程记为希尔伯特变换。</p><p><span class="math display">\[A_m \hat{\cos} w_m t = A_m \sin w_m t\]</span></p><p>式(1)可以改写为 <span class="math display">\[s_{SSB}(t) = \frac{1}{2} A_m\cos w_m t\cos w_c t \mp \frac{1}{2} A_m\hat{\cos} w_m t \sin w_c t\]</span></p><p>推广到一般情况 <span class="math display">\[s_{SSB}(t) = \frac{1}{2} m(t) \cos w_c t \mp \frac{1}{2} \hat{m}(t) \sinw_c t \tag{2}\]</span></p><p>若<span class="math inline">\(m(t) &lt;==&gt; M(w)\)</span>，那么<span class="math display">\[\hat{M}(w) = M(w) \cdot [-jsgnw] \tag{3}\]</span> 符号函数 <span class="math display">\[sgnw = \left \{ \begin{aligned}    1 ~~~~ w&gt;0 \\    -1 ~~~~ w&lt;0\end{aligned} \right. \tag{4}\]</span></p><p>系统框图</p><figure><img src="/images/SSB框图.png" title="SSB框图" alt="SSB框图" /><figcaption aria-hidden="true">SSB框图</figcaption></figure><h3 id="残留边带调制">残留边带调制</h3><p>VSB特点：不需要滤波器有十分陡峭的截止特性。</p><p>设<span class="math inline">\(H(w)\)</span>是残留边带滤波器的传函。<span class="math display">\[S_{VSB}(w) = S_{DSB}(w) \cdot H(w) = \frac{1}{2} [ M(w + w_c) + M(w -w_c) ] H(w)\]</span></p><h4 id="残留边带相干解调">残留边带相干解调</h4><p>残留边带信号<spanclass="math inline">\(s_{VSB}(t)\)</span>与相干载波<spanclass="math inline">\(2\cos w_c t\)</span>的乘积为 <spanclass="math display">\[s_p(t) = 2s_{VSB}(t) \cos w_c t\]</span> <span class="math inline">\(s_p(t)\)</span>对应的频谱为 <spanclass="math display">\[\begin{aligned}    S_p(w) &amp;= [S_{VSB}(w + w_c) + S_{VSB}(w - w_c)] \\    &amp;= \frac{1}{2} [ M(w + 2w_c) + M(w) ] H(w + w_c) + \frac{1}{2} [M(w) + M(w - 2w_c) ] H(w - w_c)\end{aligned}\tag{5}\]</span> 式中<span class="math inline">\(M(w - 2w_c),~M(w +2w_c)\)</span>是<span class="math inline">\(M(w)\)</span>搬移到<spanclass="math inline">\(2w_c\)</span>的频谱，可以用低通滤波器滤除。</p><p>滤波后得到 <span class="math display">\[S_d(w) = \frac{1}{2} M(w) [H(w + w_c) + H(w - w_c)]\]</span></p><p>为了无失真，<span class="math inline">\(H(w + w_c) + H(w -w_c)\)</span>应该是一个常数。且<span class="math inline">\(|w| \leqw_H\)</span>，<spanclass="math inline">\(w_H\)</span>是调制信号的截止频率（<spanclass="math inline">\(H(w)\)</span>必须遵循的条件）。</p><figure><img src="/images/残留边带滤波器.jpg" title="残留边带滤波器"alt="残留边带滤波器" /><figcaption aria-hidden="true">残留边带滤波器</figcaption></figure><h4 id="vsb例题">VSB例题</h4><figure><img src="/images/VSB例题.jpg" title="VSB例题" alt="VSB例题" /><figcaption aria-hidden="true">VSB例题</figcaption></figure><h2 id="四类线性调制关系">四类线性调制关系</h2><figure><img src="/images/四类线性调制关系.png" title="四类线性调制关系"alt="四类线性调制关系" /><figcaption aria-hidden="true">四类线性调制关系</figcaption></figure><h2 id="线性调制matlab代码">线性调制matlab代码</h2><p>AM调制代码</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% AM调制</span><br>f_s = <span class="hljs-number">1e6</span>; <span class="hljs-comment">%采样频率</span><br>f_m = <span class="hljs-number">1e2</span>; <span class="hljs-comment">%调制信号频率</span><br>f_c = <span class="hljs-number">8e2</span>; <span class="hljs-comment">%载波频率</span><br><br>t = <span class="hljs-number">0</span>:<span class="hljs-number">1</span>/f_s:<span class="hljs-number">1</span><span class="hljs-number">-1</span>/f_s;<br><br>A_0 = <span class="hljs-number">2</span>;<br>m_t = <span class="hljs-number">2</span>*<span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*f_m*t); <span class="hljs-comment">%调制信号</span><br>c_t = <span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*f_c*t); <span class="hljs-comment">%载波</span><br><br>s_t = (A_0 + m_t) .* c_t; <span class="hljs-comment">% 线性调制</span><br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t, s_t); <span class="hljs-comment">% 已调信号图像</span><br><br><span class="hljs-comment">% 对三种信号进行傅里叶变换获得频谱</span><br>M_w = fft(m_t);<br>C_w = fft(c_t);<br>S_w = fft(s_t);<br><br>N = <span class="hljs-built_in">length</span>(t);<br>f = (<span class="hljs-number">0</span>:N<span class="hljs-number">-1</span>)*f_s/N;<br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(f, <span class="hljs-built_in">abs</span>(M_w));<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">plot</span>(f, <span class="hljs-built_in">abs</span>(C_w));<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(f, <span class="hljs-built_in">abs</span>(S_w));<br><br>window=boxcar(<span class="hljs-built_in">length</span>(c_t)); <span class="hljs-comment">%矩形窗</span><br>[Pxx,ff]=periodogram(c_t,[],N,f_s); <span class="hljs-comment">%直接法</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(ff,Pxx);<br>title(<span class="hljs-string">&quot;M_w的功率谱密度周期图法&quot;</span>)<br><br><span class="hljs-comment">% 计算功率谱密度</span><br>p_m = <span class="hljs-built_in">abs</span>(M_w(<span class="hljs-number">1</span>:N/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>));<br>p_m = (<span class="hljs-number">1</span>/(f_s*N))*p_m.^<span class="hljs-number">2</span>;<br>p_m(<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>) = p_m(<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>)*<span class="hljs-number">2</span>;<br><span class="hljs-built_in">figure</span>(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">plot</span>(f(<span class="hljs-number">1</span>:N/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>), p_m);<br>title(<span class="hljs-string">&quot;M_w的功率谱密度&quot;</span>);<br><br>p_c = <span class="hljs-built_in">abs</span>(C_w(<span class="hljs-number">1</span>:N/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>));<br>p_c = (<span class="hljs-number">1</span>/(f_s*N))*p_c.^<span class="hljs-number">2</span>;<br>p_c(<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>) = p_c(<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>)*<span class="hljs-number">2</span>;<br><span class="hljs-built_in">figure</span>(<span class="hljs-number">5</span>);<br><span class="hljs-built_in">plot</span>(f(<span class="hljs-number">1</span>:N/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>), p_c);<br>title(<span class="hljs-string">&quot;C_w的功率谱密度&quot;</span>);<br><br>p_s = <span class="hljs-built_in">abs</span>(S_w(<span class="hljs-number">1</span>:N/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>));<br>p_s = (<span class="hljs-number">1</span>/(f_s*N))*p_s.^<span class="hljs-number">2</span>;<br>p_s(<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>) = p_s(<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>)*<span class="hljs-number">2</span>;<br><span class="hljs-built_in">figure</span>(<span class="hljs-number">6</span>);<br><span class="hljs-built_in">plot</span>(f(<span class="hljs-number">1</span>:N/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>), p_s);<br>title(<span class="hljs-string">&quot;S_w的功率谱密度&quot;</span>);<br><br><span class="hljs-comment">% 该程序中调幅系数a等于1，理论上调制效率达到最大为1/3</span><br><span class="hljs-comment">% 根据程序中的功率谱密度，可以看出调制效率为1/3</span><br><br><span class="hljs-comment">% DSB调制</span><br><br>s_dsb_t = m_t .* c_t;<br><span class="hljs-built_in">figure</span>(<span class="hljs-number">7</span>);<br><span class="hljs-built_in">plot</span>(t, s_dsb_t);<br><br><span class="hljs-comment">% SSB调制</span><br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">8</span>);<br>s_ssb_t = modulate(m_t, f_c, f_s, <span class="hljs-string">&#x27;amssb&#x27;</span>); <span class="hljs-comment">% 搞不懂希尔伯特变换，偷懒了[doge]</span><br><span class="hljs-built_in">plot</span>(t, <span class="hljs-built_in">abs</span>(s_ssb_t));<br><br><span class="hljs-comment">% vsb调制</span><br><span class="hljs-comment">% 自己构造一个H(w)，然后直接和DSB信号的频谱相乘，在matlab里面实现很简单</span><br><span class="hljs-comment">% 但是要做实时通信的话，我不知道该怎么做。</span><br><br></code></pre></td></tr></table></figure><h2 id="角度调制">角度调制</h2><p>基本概念：载波的频率随调制信号变化称为调频（FM）。载波相位随调制信号变化称为调相（PM）。调制过程幅值不发生变化。统称角度调制。</p><p>特点：已调信号不再是原调制信号的频谱搬移，而是频谱的非线性变换。所以是非线性调制。</p><p>优势：较高的抗噪声性能 缺点：较大的带宽</p><p>FM,PM的一般表达式 <span class="math display">\[s_m(t) = A\cos [w_c t + \phi (t)] \tag{6}\]</span></p><p><span class="math inline">\(A\)</span>是载波的恒定振幅；<spanclass="math inline">\([w_c t + \phi(t)]\)</span>是信号的瞬时相位，记为<spanclass="math inline">\(\theta(t)\)</span>；<spanclass="math inline">\(\phi(t)\)</span>为相对于载波相位<spanclass="math inline">\(w_c t\)</span>的瞬时相位偏移；<spanclass="math inline">\(d[w_c t + \phi(t)]/dt\)</span>是信号的瞬时角频率，记为<spanclass="math inline">\(w(t)\)</span>；<spanclass="math inline">\(d\phi(t)/dt\)</span>是相对于载频<spanclass="math inline">\(w_c\)</span>的瞬时频偏。</p><p>PM：瞬时相位偏移随调制信号作线性变化 <span class="math display">\[\phi(t) = K_p m(t) \tag{7}\]</span></p><p>(7)带入(6) <span class="math display">\[s_{PM}(t) = A\cos [w_c t + K_p m(t)]\]</span></p><p>FM：瞬时频率偏移随调制信号作线性变化 <span class="math display">\[\frac{ d\phi(t) }{dt} = K_f m(t) \tag{8}\]</span></p><p>(8)带入(6) <span class="math display">\[s_{FM} = A\cos [w_c t + K_f \int m(\tau)d\tau]\]</span></p><p>如果预先不知道调制信号<spanclass="math inline">\(m(t)\)</span>的具体形式，则无法判断已调信号是调相还是调频。</p><h3 id="单频调制fm与pm">单频调制FM与PM</h3><p>设调制信号为单一频率的正弦波 <span class="math display">\[m(t) = A_m\cos w_m t = A_m\cos 2\pi f_m t\]</span> 对载波进行相位调制 <span class="math display">\[\begin{aligned}    s_{PM}(t) &amp;= A\cos [w_c t + K_p A_m \cos w_m t]    &amp;= A\cos [w_c t + m_p \cos w_m t]\end{aligned}\]</span> <spanclass="math inline">\(m_p\)</span>称为调相指数，表示最大的相位偏移</p><p>对载波进行频率调制 <span class="math display">\[\begin{aligned}    s_{FM}(t) &amp;= A\cos [w_c t + K_f A_m \int \cos w_m \tau d\tau] \\    &amp;= A\cos [w_c t + m_f \sin w_m t]\end{aligned}\]</span> <span class="math inline">\(m_f\)</span>是调频指数 <spanclass="math display">\[m_f = \frac{ K_f A_m }{ w_m } = \Delta w / w_m = \Delta f / f_m\]</span></p><p><span class="math inline">\(\Delta w\)</span>是最大角频偏；<spanclass="math inline">\(\Delta f\)</span>是最大频偏</p><p>波形</p><figure><img src="/images/FMPM波形.jpg" title="FMPM波形" alt="FMPM波形" /><figcaption aria-hidden="true">FMPM波形</figcaption></figure><h3 id="fm与pm之间的关系">FM与PM之间的关系</h3><p>FM和PM可以相互转换</p><h4 id="窄带调频nbfm">窄带调频（NBFM）</h4><p>FM信号最大瞬时相移满足 <span class="math display">\[\left| K_f \int m(\tau) d\tau  \right| \ll \frac{\pi}{6} ~~~~ (或0.5)\tag{9}\]</span></p><p>FM信号一般表达式（6）展开得到 <span class="math display">\[\begin{aligned}    s_{FM}(t) &amp;= A\cos [w_c t + K_f \int m(\tau) d\tau] \\    &amp;= A\cos w_c t \cos [ K_f \int m(\tau) d\tau ] - A\sin w_c t\sin [K_f \int m(\tau) d\tau]\end{aligned} \tag{10}\]</span> 满足式（9）时，有 <span class="math display">\[\cos [ K_f \int m(\tau) d\tau ] \approx 1\]</span> <span class="math display">\[\sin [K_f \int m(\tau) d\tau] \approx K_f \int m(\tau) d\tau\]</span></p><p>所以（10）可以化简为 <span class="math display">\[s_{NBFM} (t) \approx A\cos w_c t - [ A K_f \int m(\tau) d\tau] \sin w_ct\]</span> 其频域表达式 <span class="math display">\[S_{NBFM} (w) = \pi A [\delta(w + w_c) + \delta (w - w_c)] +\frac{AK_f}{2} \left[ \frac{M(w - w_c)}{w-w_c} -\frac{M(w+w_c)}{w+w_c}\right]\]</span></p><p>和AM的频谱比较， <span class="math display">\[S_{AM}(w) = \pi A[\delta(w + w_c) + \delta (w - w_c)] + \frac{1}{2}[M(w-w_c) + M(w+w_c)]\]</span> 二者都含有一个载波和位于<span class="math inline">\(\pmw\)</span>处的两个边带，所以他们的带宽相同，都是调制信号最高频率的两倍。不同的是，NBFM的两个边频分别乘了因式<spanclass="math inline">\(1/(w - w_c),~~ 1/(w + w_c)\)</span>，由于因式是频率的函数，所以这种加权是<strong>频率的加权</strong>，加权结果<strong>引起调制信号频谱失真</strong>。另外，<strong>NBFM的一个边带和AM反相</strong>。</p><h4 id="宽带调频">宽带调频</h4><p>不满足式（9）的时候，就是宽带调频</p><p>设调制信号为单一频率的正弦波 <span class="math display">\[m(t) = A_m\cos w_m t = A_m\cos 2\pi f_m t\]</span> <span class="math display">\[s_{FM}(t) = A\cos [w_c t + m_f \sin w_m t]\]</span> 将<span class="math inline">\(s_{FM}(t)\)</span>展开 <spanclass="math display">\[s_{FM}(t) = A\cos w_c t \cdot \cos (m_f \sin w_m t) - A\sin w_c t \cdot\sin (m_f \sin w_m t) \tag{11}\]</span> 将式中两个因子分别展开成如下傅里叶级数 <spanclass="math display">\[\begin{aligned}    \cos (m_f \sin w_m t) = J_0(m_f) + \sum_{n=1}^{\infty}2J_{2n}(m_f)\cos 2n w_m t \\    \sin (m_f \sin w_m t) = 2 \sum_{n=1}^{\infty} 2J_{2n-1}(m_f)\sin(2n-1) w_m t\end{aligned} \tag{12}\]</span> <spanclass="math inline">\(J_{n}(m_f)\)</span>为第一类n阶贝塞尔函数</p><p>将（12）带入（11），利用贝塞尔函数性质 <span class="math display">\[J_{-n}(m_f) = -J_{n}(m_f) ~~~~ n是奇数\]</span> <span class="math display">\[J_{-n}(m_f) = J_{n}(m_f) ~~~~ n是偶数\]</span></p><p>得到FM信号傅里叶级数展开式为 <span class="math display">\[s_{FM}(t) = A\sum_{n=-\infty}^{\infty} J_n (m_f) \cos (w_c + nw_m) t\]</span> 其频谱 <span class="math display">\[S_{FM}(w) = \pi A \sum_{n=-\infty}^{\infty} J_n (m_f) [\delta(w - w_c-nw_m) + \delta(w + w_c + nw_m)]\]</span></p><p>贝塞尔函数图像： <img src="/images/贝塞尔函数.jpg" title="贝塞尔函数"alt="贝塞尔函数" /></p><p>调频频谱图像： <img src="/images/调频频谱.jpg" title="调频频谱"alt="调频频谱" /></p><p>调频信号的带宽：调频信号的频谱看似有无限多频率分量，理论上需要无限大带宽。实际上<spanclass="math inline">\(J_n (m_f)\)</span>随着<spanclass="math inline">\(n\)</span>的增大而逐渐减小。因此只要<strong>取适当的n值使边频分量小到可以忽略的程度，调频信号可近似认为具有有限频谱</strong>。通常采用的原则是：信号的频带宽度应包括幅度大于未载波的10%以上的边频分量，即<spanclass="math inline">\(|J_n (m_f)|\geq 0.1\)</span>。当<spanclass="math inline">\(m_f \geq 1\)</span>以后，取边频数<spanclass="math inline">\(n=m_f+1\)</span>即可。</p><p>调频波的有效带宽为： <span class="math display">\[B_{FM} = 2(m_f + 1)f_m = 2(\Delta f + f_m) \tag{13}\]</span> 式（13）就是计算调频带宽的卡森（Carson）公式</p><p>当<span class="math inline">\(m_j \ll 1\)</span>时 <spanclass="math display">\[B_{FM} \approx 2f_m ~~~~ (NBFM)\]</span></p><p>当<span class="math inline">\(m_j \gg 1\)</span>时 <spanclass="math display">\[B_{FM} \approx 2\Delta f ~~~~ (WBFM)\]</span></p><p>当信号不是单一频率时候： <span class="math display">\[B_{FM} = 2(m_f + 1)f_m = 2(\Delta f + f_m)\]</span> <spanclass="math inline">\(f_m\)</span>是调制信号的最高频率，<spanclass="math inline">\(m_f\)</span>是调制信号的最大频偏。</p><p>调频信号功率分配</p><p>调频信号<span class="math inline">\(s_{FM}(t)\)</span>在<spanclass="math inline">\(1\Omega\)</span>电阻上消耗的平均功率为： <spanclass="math display">\[P_{FM} = \overline{s_{FM}^{2} (t)}\]</span> 利用帕塞瓦尔定理 <span class="math display">\[P_{FM} = \overline{s_{FM}^{2} (t)} =\frac{A^2}{2}\sum_{n=-\infty}^{\infty} J_n^2 (m_f)\]</span> 贝塞尔函数性质： <span class="math display">\[\sum_{n=-\infty}^{\infty} J_n^2 (m_f) = 1\]</span> 因此 <span class="math display">\[P_{FM} = \frac{A^2}{2} = P_c\]</span> <spanclass="math inline">\(P_c\)</span>是未调载波的平均功率。调制后总功率不变，只是将原来的功率中的一部分分配给每个边频分量。调制的过程只是进行功率的重新分配，分配的原则与调频指数<spanclass="math inline">\(m_f\)</span>有关。</p><h3 id="调频信号产生与解调">调频信号产生与解调</h3><h4 id="直接调频法">直接调频法</h4><p>压控振荡器：可以由外部电压控制振荡频率的振荡器（VCO）。</p><p>每个压控振荡器自身就是FM调制器，因为振荡频率正比于输入控制电压 <spanclass="math display">\[w_i(t) = w_0 + K_f m(t)\]</span></p><p>优缺点： - 优点：线性调频，频偏较大。 - 缺点：频率稳定度不高</p><p>运用锁相环（PLL）调制器可以提高频率稳定度，但是低频调制特性差。</p><h4 id="间接调频法">间接调频法</h4><p>先将调制信号积分，然后对载波进行调相，即可产生一个NBFM信号，再经过n次倍频器得到</p><p>优缺点： - 优点：频率稳定度好 - 缺点：需要多次倍频混频，电路复杂</p><p>获得NBFM：</p><figure><img src="/images/调频系统框图.jpg" title="调频系统框图"alt="调频系统框图" /><figcaption aria-hidden="true">调频系统框图</figcaption></figure><p><span class="math display">\[s_{NBFM} (t) \approx A\cos w_c t - [ A K_f \int m(\tau) d\tau] \sin w_ct\]</span></p><p>要将NBFM信号倍频得到WBFM信号，需要倍频器。</p><p>理想平方律器件： <span class="math display">\[s_o(t) = as_i^2(t)\]</span></p><p>当<span class="math inline">\(s_i(t) = A\cos[w_c t +\phi(t)]\)</span></p><p><span class="math display">\[s_o(t) = \frac{1}{2} aA^2 \left\{ 1 + \cos[ 2w_c t + 2\phi(t) ] \right\}\]</span></p><p>可以看到载波频率和调频指数都变为原来的两倍。</p><p>来道例题~~</p><figure><img src="/images/阿姆斯特朗.jpg" title="阿姆斯特朗" alt="阿姆斯特朗" /><figcaption aria-hidden="true">阿姆斯特朗</figcaption></figure><h4 id="调频信号解调">调频信号解调</h4><p>相干解调仅适用于NBFM信号。非相干解调对NBFM、WBFM均适用。</p><p>调频信号一般表达式 <span class="math display">\[s_{FM}(t) = A\cos [w_c t + K_f \int m(\tau) d\tau]\]</span> 解调器输出 <span class="math display">\[m_o(t) \propto K_f m(t)\]</span></p><h5 id="非相干解调">非相干解调</h5><p>解调需要产生一个与输入调频信号的频率呈线性关系的输出电压。完成这种频率——电压转换关系的器件是频率检波器，简称鉴频器。</p><p>鉴频器 = 微分器 + 包络检波器</p><p>调频信号<spanclass="math inline">\(s_{FM}(t)\)</span>经过微分器输出为 <spanclass="math display">\[s_d(t) = -A[ w_c + K_f m(t) ] \sin \left[ w_c t + K_f \int m(\tau) d\tau\right]\]</span></p><p>包络检波器将幅度变化检出并滤去直流，低通滤波后输出 <spanclass="math display">\[m_o(t) = K_d K_f m(t)\]</span> <span class="math inline">\(K_d\)</span>为鉴频器灵敏度。</p><h5 id="相干解调">相干解调</h5><p>窄带调频信号 <span class="math display">\[s_{NBFM} (t) \approx A\cos w_c t - [ A K_f \int m(\tau) d\tau] \sin w_ct\]</span></p><p>相干载波 <span class="math display">\[c(t) = -\sin w_c t\]</span></p><p>二者相乘 <span class="math display">\[s_p(t) = - \frac{A}{2} \sin 2w_c t + \frac{A}{2} \left[ K_f \intm(\tau)]d\tau \right] \cdot (1 - \cos 2w_c t)\]</span></p><p>低通滤波 <span class="math display">\[s_d (t) = \frac{A}{2} K_f \int m(\tau)]d\tau\]</span></p><p>经过微分器处理 <span class="math display">\[m_o(t) = \frac{ AK_f  }{ 2 } m(t)\]</span></p><h2 id="抗噪声性能">抗噪声性能</h2><p>信道中加性高斯白噪声是普遍存在的噪声。加性噪声被认为只对已调信号的接收产生影响。<strong>通信系统的抗噪声性能可以用解调器的抗噪声性能衡量</strong></p><figure><img src="/images/噪声分析模型.png" title="噪声分析模型"alt="噪声分析模型https://www.bilibili.com/video/BV1wA4y1f7Co?p=24" /><figcaptionaria-hidden="true">噪声分析模型https://www.bilibili.com/video/BV1wA4y1f7Co?p=24</figcaption></figure><p>一般认为图中<spanclass="math inline">\(n_i(t)\)</span>是平稳窄带高斯噪声 <spanclass="math display">\[n_i(t) = n_c(t) \cos w_0 t - n_s(t) \sin w_0 t\]</span> <spanclass="math inline">\(w_0\)</span>是带通滤波器的中心频率</p><p><span class="math display">\[\overline{ n_i^2(t) } = \overline{ n_c^2(t) } = \overline{ n_s^2(t) } =N_i = n_0 B\]</span> <spanclass="math inline">\(n_0\)</span>是白噪声功率谱密度，<spanclass="math inline">\(B\)</span>是带通滤波器带宽也是已调信号频带宽度。</p><p>信噪比 <span class="math display">\[\frac{S_o}{N_o} = \frac{ 解调器输出有用信号的平均功率 }{解调器输出噪声的平均功率 } = \frac{ \overline{m_o^2(t)} }{ n_o^2(t) }\]</span></p><p>为了便于比较同类调制系统采用不同解调器时的性能，引入输出信噪比和输入信噪比的比值——调制制度增益或信噪比增益<spanclass="math inline">\(G\)</span> <span class="math display">\[G = \frac{ S_o/N_o }{ S_i / N_i }\]</span> <spanclass="math inline">\(G\)</span>的大小反应调制制度的优劣。</p><p><span class="math display">\[\frac{S_i}{N_i} = \frac{ 解调器输入已调信号的平均功率 }{解调器输入噪声的平均功率 } = \frac{ \overline{s_m^2(t)} }{ n_i^2(t) }\]</span></p><h3 id="线性系统抗噪声性能">线性系统抗噪声性能</h3><figure><img src="/images/带通滤波器中心频率.png" title="带通滤波器中心频率"alt="带通滤波器中心频率https://www.bilibili.com/video/BV1wA4y1f7Co?p=24" /><figcaptionaria-hidden="true">带通滤波器中心频率https://www.bilibili.com/video/BV1wA4y1f7Co?p=24</figcaption></figure><h4 id="dsb系统噪声">DSB系统噪声</h4><figure><img src="/images/DSB噪声.png" title="DSB噪声" alt="DSB噪声" /><figcaption aria-hidden="true">DSB噪声</figcaption></figure><figure><img src="/images/DSB信噪比.png" title="DSB信噪比" alt="DSB信噪比" /><figcaption aria-hidden="true">DSB信噪比</figcaption></figure><h4 id="ssb系统噪声">SSB系统噪声</h4><figure><img src="/images/SSB噪声.png" title="SSB噪声" alt="SSB噪声" /><figcaption aria-hidden="true">SSB噪声</figcaption></figure><figure><img src="/images/SSB信噪比.png" title="SSB信噪比" alt="SSB信噪比" /><figcaption aria-hidden="true">SSB信噪比</figcaption></figure><h4 id="dsbssb抗噪声性能比较">DSB,SSB抗噪声性能比较</h4><p>输入功率<span class="math inline">\(S_i\)</span>，功率谱密度<spanclass="math inline">\(n_0\)</span>，基带信号最高频率<spanclass="math inline">\(f_H\)</span>都相同时</p><p>DSB带宽<span class="math inline">\(B=2f_H\)</span>，SSB带宽<spanclass="math inline">\(B=f_H\)</span></p><p><span class="math display">\[\left( \frac{S_o}{N_o} \right)_{DSB} = 2 \frac{S_i}{N_i} =\frac{S_i}{n_0 f_H}\]</span></p><p><span class="math display">\[\left( \frac{S_o}{N_o} \right)_{SSB} = \frac{S_i}{N_i} = \frac{S_i}{n_0f_H}\]</span></p><p><strong>DSB,SSB抗噪声性能相同</strong></p><h4 id="am系统噪声">AM系统噪声</h4><p>输入信号 <span class="math display">\[s_m(t) = [A_0 + m(t)] \cos w_ct\]</span> 噪声 <span class="math display">\[n_i(t) = n_c(t)\cos w_c t - n_s(t) \sin w_c t\]</span></p><p><span class="math display">\[S_i = \overline{ s_m^2(t) } = \frac{A_0}{2} + \frac{ \overline{ m^2(t) }}{2}\]</span> <span class="math display">\[N_i = \overline{ n_i^2(t) } = n_0 B\]</span></p><p><span class="math display">\[\frac{S_i}{N_i} = \frac{ A_0^2 + \overline{ m^2(t) } }{ 2n_0 B }\]</span></p><p>解调器输入的时混合波形 <span class="math display">\[s_m (t) + n_i (t) = E(t) \cos [ w_c t + \Phi(t) ]\]</span> <span class="math display">\[E(t) = \sqrt{ [ A_0 + m(t) + n_c(t) ]^2  + n_s^2(t)}\]</span> <span class="math display">\[\Phi(t) = \arctan \left[ \frac{n_s(t)}{  A_0 + m(t) + n_c(t) } \right]\]</span></p><p>显然<span class="math inline">\(E(t)\)</span>是所求包络。</p><p>大信噪比情况：</p><p><span class="math display">\[[A_0 + m(t)] \gg \sqrt{ n_c^2(t)  + n_s^2(t) }\]</span> <span class="math inline">\(E(t)\)</span>可以化简为 <spanclass="math display">\[E(t) = A_0 + m(t) + n_c(t)\]</span></p><ul><li>注：利用近似公式<span class="math inline">\((1 + x)^{1/2} \approx 1+ x/2\)</span></li></ul><p>输出信号功率为 <span class="math display">\[S_o = \overline{ m^2(t) }\]</span> 输出噪声功率 <span class="math display">\[N_o = \overline{ n_c^2(t) } = \overline{ n_i^2(t) } = n_0B\]</span> 输出信噪比 <span class="math display">\[\frac{S_o}{N_o} = \frac{ \overline{ m^2(t) } }{ n_0B }\]</span></p><p>调制制度增益 <span class="math display">\[G = \frac{ 2\overline{ m^2(t) } }{ A_0^2 + \overline{ m^2(t) } }\]</span> <span class="math inline">\(G\)</span>最大为<spanclass="math inline">\(2/3\)</span></p><p>小信噪比情况</p><p><span class="math display">\[E(t) = R(t) \sqrt{ 1 + \frac{ 2[A_0 + m(t)] }{ R(t) } \cos \theta(t) }\]</span> 其中 <span class="math display">\[\begin{aligned}    R(t) = \sqrt{ n_c^2(t) + n_s^2(t) } \\    \theta(t) = \arctan \left[ \frac{ n_s(t) }{ n_c(t) } \right] \\    \cos \theta (t) = \frac{ n_c(t) }{R(t)}\end{aligned}\]</span></p><p>再次利用近似公式<span class="math inline">\((1 + x)^{1/2} \approx 1 +x/2\)</span></p><p><span class="math display">\[E(t) = R(t) + [A_0 + m(t)]\cos \theta(t)\]</span></p><h3 id="非线性系统抗噪声性能">非线性系统抗噪声性能</h3><figure><img src="/images/FM鉴频器抗噪声性能.png" title="FM鉴频器抗噪声性能"alt="FM鉴频器抗噪声性能" /><figcaption aria-hidden="true">FM鉴频器抗噪声性能</figcaption></figure><h3 id="性能比较">性能比较</h3><figure><img src="/images/性能比较.png" title="性能比较" alt="性能比较" /><figcaption aria-hidden="true">性能比较</figcaption></figure><h2 id="频分复用fdm">频分复用FDM</h2><figure><img src="/images/频分复用FDM.png" title="频分复用FDM"alt="频分复用FDM" /><figcaption aria-hidden="true">频分复用FDM</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>通信原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信笔记4</title>
    <link href="/2024/07/17/%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B04/"/>
    <url>/2024/07/17/%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B04/</url>
    
    <content type="html"><![CDATA[<h1 id="信道">信道</h1><p>定义：以传输媒质为基础的信号通道</p><p>狭义信道</p><ul><li>有线信道 同轴电缆，光纤等</li><li>无线信道 微波视距传播，卫星中继，移动通信等</li></ul><p>广义信道</p><ul><li>调制信道 研究调制解调问题</li><li>编码信道 研究编码译码问题</li></ul><figure><img src="/images/信道.png" title="信道定义拓扑关系图"alt="信道定义拓扑关系图https://www.bilibili.com/video/BV1wA4y1f7Co?p=12" /><figcaptionaria-hidden="true">信道定义拓扑关系图https://www.bilibili.com/video/BV1wA4y1f7Co?p=12</figcaption></figure><p>恒参信道：信道传输特性随时间<strong>缓慢变化或不变化</strong>的信道。比如各种有线信道</p><p>随参信道：信道传输特性随时间<strong>随机快速变化</strong>的信道。比如短波电离层反射，各种散射，移动通信等信道</p><h2 id="调制信道">调制信道</h2><p>调制信道的特点</p><ul><li>有一对/多对输入/输出端</li><li>大多满足线性叠加原理</li><li>对信号有固定或时变的延迟（相位）和损耗（幅值）</li><li>无信号输入，仍有可能输出，此时输出噪声</li></ul><p>调制信道的数学模型：叠加有噪声的线性时不变/时变滤波器</p><figure><img src="/images/调制信道数学模型.png" title="调制信道的数学模型"alt="调制信道的数学模型https://www.bilibili.com/video/BV1wA4y1f7Co?p=12" /><figcaptionaria-hidden="true">调制信道的数学模型https://www.bilibili.com/video/BV1wA4y1f7Co?p=12</figcaption></figure><p>恒参信道对应线性时不变滤波器<span class="math inline">\(c(t)&lt;==&gt; C(w)\)</span>，随参信道对应线性时变滤波器<spanclass="math inline">\(c(t,\tau) &lt;==&gt; C(w,\tau)\)</span></p><h2 id="编码信道">编码信道</h2><p>编码信道数学模型</p><figure><img src="/images/编码信道数学模型.png" title="编码信道的数学模型"alt="编码信道的数学模型https://www.bilibili.com/video/BV1wA4y1f7Co?p=12" /><figcaptionaria-hidden="true">编码信道的数学模型https://www.bilibili.com/video/BV1wA4y1f7Co?p=12</figcaption></figure><p>编码信道分类：无记忆信道（前后码元发生的错误相互独立），有记忆信道（一个码元发生错误和前后码元有依赖关系，使用马尔可夫链描述）</p><h2 id="理想恒参信道">理想恒参信道</h2><p>理想无失真传输信道可以等效为一个线性时不变网络</p><p>理想恒参信道满足无失真传输条件，即输入输出波形结构一致，只是幅度和出现时间不同</p><figure><img src="/images/无失真传函.png" title="无失真传函数学模型"alt="无失真传函数学模型https://www.bilibili.com/video/BV1wA4y1f7Co?p=12" /><figcaptionaria-hidden="true">无失真传函数学模型https://www.bilibili.com/video/BV1wA4y1f7Co?p=12</figcaption></figure><p>系统输入输出管旭和冲击响应</p><figure><img src="/images/理想恒参信道系统.png" title="理想恒参信道系统"alt="理想恒参信道系统https://www.bilibili.com/video/BV1wA4y1f7Co?p=13" /><figcaptionaria-hidden="true">理想恒参信道系统https://www.bilibili.com/video/BV1wA4y1f7Co?p=13</figcaption></figure><h3 id="失真">失真</h3><figure><img src="/images/信道失真曲线分析.png" title="信道失真曲线分析"alt="信道失真曲线分析https://www.bilibili.com/video/BV1wA4y1f7Co?p=13" /><figcaptionaria-hidden="true">信道失真曲线分析https://www.bilibili.com/video/BV1wA4y1f7Co?p=13</figcaption></figure><p>幅频失真对信号的影响</p><ul><li>幅频失真对模拟信号的影响：发生波形失真，导致信噪比下降</li><li>幅频失真对数字信号的影响：发生码间干扰，导致误码率增大</li></ul><p>相频失真对信号的影响</p><ul><li>相频失真对模拟信号的影响：对语音信号影响不大（人耳不易分辨），对视频信号影响大</li><li>相频失真对数字信号的影响：发生码间干扰，导致误码率增大</li></ul><p>改善线性失真的措施：采用均衡技术：向无失真传输特性靠拢</p><p>例题</p><figure><img src="/images/例题失真.jpg" title="例题"alt="例题https://www.bilibili.com/video/BV1wA4y1f7Co?p=13" /><figcaptionaria-hidden="true">例题https://www.bilibili.com/video/BV1wA4y1f7Co?p=13</figcaption></figure><h2 id="随参信道">随参信道</h2><p>随参信道特性</p><figure><img src="/images/随参信道特性.png" title="随参信道特性"alt="随参信道特性https://www.bilibili.com/video/BV1wA4y1f7Co?p=13" /><figcaptionaria-hidden="true">随参信道特性https://www.bilibili.com/video/BV1wA4y1f7Co?p=13</figcaption></figure><h3 id="多途径传播影响">多途径传播影响</h3><p><span class="math display">\[s(t) = A\cos(w_c t) ~~~~ ==&gt; ~~~~ r(t) = \sum_{i=1}^na_i(t)\cos(w_c(t - \tau_i(t) ))\]</span></p><p>其中<spanclass="math inline">\(r(t)\)</span>是包络和相位随机缓慢变化的窄带信号。<spanclass="math inline">\(a_i(t)\)</span>是时变衰弱，<spanclass="math inline">\(\tau_i(t)\)</span>是时变时延</p><p>把<spanclass="math inline">\(r(t)\)</span>拆解成同相分量和正交分量：</p><p><span class="math display">\[\begin{aligned}    r(t) &amp;= \sum_{i=1}^n a_i(t)\cos(w_c t - \phi_i(t) ) ~~~~\phi_i(t) = w_c\tau_i(t) \\    &amp;= \sum_{i=1}^n a_i(t) \cos \phi_i(t) \cos w_c t - \sum_{i=1}^na_i(t) \sin \phi_i(t) \sin w_c t \\    &amp;= X(t)\cos w_c t - Y(t) \sin w_c t \\    &amp;= V(t)\cos [w_c t + \phi (t)]\end{aligned}\]</span></p><p><span class="math display">\[V(t) = \sqrt{ X(t)^2 + Y(t)^2 }, ~~~~ \phi(t) = \arctan\frac{Y(t)}{X(t)}\]</span></p><p>多径传播影响：</p><figure><img src="/images/多径传播的影响.png" title="多径传播的影响"alt="多径传播的影响https://www.bilibili.com/video/BV1wA4y1f7Co?p=13" /><figcaptionaria-hidden="true">多径传播的影响https://www.bilibili.com/video/BV1wA4y1f7Co?p=13</figcaption></figure><p>两径传播模型：</p><figure><img src="/images/两径传播模型.png" title="两径传播模型"alt="两径传播模型https://www.bilibili.com/video/BV1wA4y1f7Co?p=13" /><figcaptionaria-hidden="true">两径传播模型https://www.bilibili.com/video/BV1wA4y1f7Co?p=13</figcaption></figure><p><span class="math display">\[s_o(t) = Ks_i(t) + Ks_i(t-\tau)\]</span> <span class="math display">\[S_o(w) = KS_i(w) + KS_i(w)e^{-jw\tau} = KS_i(w)(1 + e^{-jw\tau}) =2K\cos \frac{w\tau}{2} e^{ -j\frac{w\tau}{2} }\]</span></p><p>幅频特性 <span class="math display">\[\left| H(w) \right| = 2K \left| \cos \frac{w\tau}{2} \right|\]</span>频率选择性衰弱：信道对不同频率的信号成分有不同的衰减，且随时间变化，这种现象称为频率选择性衰落。</p><p>信道相关带宽：</p><p>相邻传输零点的频率间隔为信道相关带宽<spanclass="math inline">\(\Delta f = \frac{1}{\tau}\)</span></p><p>为避免频率选择性衰落，应使信号带宽满足 <spanclass="math inline">\(B_s &lt; \Delta f\)</span></p><p>工程上一般选取<span class="math inline">\(B_s = \left( 1/5 \sim 1/3\right) \Delta f\)</span> 码元宽度满足<span class="math inline">\(T_B =(3\sim 5)\tau\)</span></p><p>两径推广至多径</p><p><span class="math inline">\(\tau_{max}\)</span>为最大的路径时延差<span class="math display">\[\Delta f = \frac{1}{\tau_{max}}\]</span></p><p>解决方法：OFDM技术</p><p>将信道划分为N个正交子信道，从而将高速的串行数据信号划分为N路并行的低速子数据流，分别调制到各路的载波上并行传输，从而使码长变大，带宽减小，并小于信道的相关带宽。</p><p>频率选择性衰落的解决方法:</p><p>分集接收、扩频、MIMO、均衡等</p><p>将接收到的信号按照一定的分集方式分离成不相关的多路信号，然后再按照一定的规则合并，目的是最大化接收信号能量，提高信号的载噪比。</p><p>常见的分集方式有空间分集、频率分集、角度分集、极化分集等；常见的合并方式有最佳选择式、等增益相加式、最大比值相加式等。</p><h2 id="噪声与带宽">噪声与带宽</h2><p>分类：</p><ul><li>按噪声来源分类<ul><li>人为噪声、自然噪声、内部噪声（如热噪声）等。</li></ul></li><li>按噪声性质分类<ul><li>脉冲噪声、窄带/单频噪声、起伏噪声等。</li></ul></li></ul><p>其中起伏噪声对信号干扰最为严重，包含热噪声、散弹噪声、宇宙噪声等。</p><p>热噪声定义：零均值高斯白噪声</p><p>热噪声三个特点</p><ul><li>来自一切电阻性元器件中电子的热运动</li><li>其功率谱均匀分布在<span class="math inline">\(0 \sim10^{12}Hz\)</span>频率范围内，可视为白噪声</li><li>其电压瞬时值服从高斯分布，且均值为0</li></ul><p>信道加性噪声：典型的信道加性噪声代表是起伏噪声（热噪声等），它是零均值的高斯白噪声。</p><p>等效噪声带宽（在功率谱面积上等效）：</p><figure><img src="/images/等效噪声带宽.png" title="等效噪声带宽"alt="等效噪声带宽https://www.bilibili.com/video/BV1wA4y1f7Co?p=13" /><figcaptionaria-hidden="true">等效噪声带宽https://www.bilibili.com/video/BV1wA4y1f7Co?p=13</figcaption></figure><h2 id="信道容量">信道容量</h2><h3 id="离散信道容量">离散信道容量</h3><p>离散信道容量有两种不同的单位</p><ul><li>用每个符号（symbol）能够传输的平均信息量最大值表示信道容量<spanclass="math inline">\(C\)</span></li><li>用单位时间（秒）内能够传输的平均信息量最大值表示信道容量<spanclass="math inline">\(C_t\)</span></li></ul><p>二者可以互换</p><p>借助书本《通信原理（第七版）》P79图4-24 <imgsrc="/images/信道模型.jpg" title="信道模型" alt="信道模型" /></p><p>图中发送符号<span class="math inline">\(x_1, x_2, x_3, \cdotsx_n\)</span>的出现概率为<span class="math inline">\(P(x_i), i=1,2,\cdotsn\)</span>；收到<span class="math inline">\(y_i\)</span>的概率是<spanclass="math inline">\(P(y_j), j=1,2,\cdots m\)</span>。</p><p><span class="math inline">\(P(y_j/x_i)\)</span>是转移概率，即发送<spanclass="math inline">\(x_i\)</span>条件下收到<spanclass="math inline">\(y_j\)</span>的条件概率。</p><p>发送<span class="math inline">\(x_i\)</span>到<spanclass="math inline">\(y_j\)</span>所获得的信息量等于发送<spanclass="math inline">\(x_i\)</span>前接收端对<spanclass="math inline">\(x_i\)</span>的不确定程度（<spanclass="math inline">\(x_i\)</span>的信息量）减去收到<spanclass="math inline">\(y_j\)</span>后接收端对<spanclass="math inline">\(x_i\)</span>的不确定程度（给定<spanclass="math inline">\(y_j\)</span>条件下<spanclass="math inline">\(x_i\)</span>的不确定程度），即发送<spanclass="math inline">\(x_i\)</span>时收到<spanclass="math inline">\(y_j\)</span>所获得的信息量<spanclass="math inline">\(~ = -\log_2 P(x_i) - [ -\log_2 P(x_i/y_j)]\)</span>对所有<spanclass="math inline">\(x_i,y_j\)</span>取统计平均值，得出收到一个符号时获得的平均信息量：<span class="math display">\[\begin{aligned}平均信息量/符号 &amp;= - \sum_{i=1}^n P(x_i)\log_2 P(x_i) - \left[ -\sum_{j=1}^m P(y_j) \sum_{i=1}^n P(x_i/y_j)\log_2 P(x_i/y_j) \right] \\&amp;= H(x) - H(x/y)\end{aligned} \tag{1}\]</span></p><p>式(1)中<span class="math inline">\(H(x)\)</span>是发送符号<spanclass="math inline">\(x_i\)</span>的平均信息量，称为信源的<strong>熵</strong>。<spanclass="math inline">\(H(x/y)\)</span>是接收<spanclass="math inline">\(y_j\)</span>已知后，发送<spanclass="math inline">\(x_i\)</span>的平均信息量</p><p>对于二进制信源，假设发送1的概率为<span class="math inline">\(P(1) =\alpha\)</span>，那么发送0的概率为<span class="math inline">\(P(1) = 1-\alpha\)</span> <span class="math display">\[H(\alpha) = -\alpha \log_2 \alpha - (1-\alpha) \log_2 (1 - \alpha)\tag{2}\]</span> 按式(2)绘制曲线，当两个符号出现概率相等（<spanclass="math inline">\(\alpha =0.5\)</span>），不确定性最大，信息量最多，对应通信笔记1中“等概率离散消息度量”有关内容。</p><figure><img src="/images/二进制信源的熵.jpg" title="二进制信源的熵"alt="二进制信源的熵" /><figcaption aria-hidden="true">二进制信源的熵</figcaption></figure><p>没有噪声时，<span class="math inline">\(H(x/y)=0\)</span></p><p>每个符号传输的平均信息量和信源发送符号概率<spanclass="math inline">\(P(x_i)\)</span>有关。<spanclass="math inline">\(H(x) - H(x/y)\)</span>对<spanclass="math inline">\(P(x_i)\)</span>求最大值得到信道容量<spanclass="math inline">\(C\)</span> <span class="math display">\[C = \max_{P(x)} [H(x) - H(x/y)] ~~~~ b/符号\]</span></p><p>设单位时间内传输符号个数<span class="math inline">\(r~~符号/s\)</span></p><p><span class="math display">\[C_t = \max_{P(x)} { r[ H(x) - H(x/y) ] } ~~~~ b/s\]</span></p><p>直接拍一张例题理解一下吧，我懒得码字了[doge] <imgsrc="/images/离散信道容量例题.jpg" title="离散信道容量例题"alt="离散信道容量例题" /></p><h3 id="连续信道容量">连续信道容量</h3><p>直接放公式 <span class="math display">\[C_t = B\log_2 (1 + \frac{S}{N}) = B\log_2 (1 + \frac{S}{n_0 B}) =\frac{S}{n_0} \log_2 (1+x)^{1/x} ~~~~ b/s\]</span> <span class="math inline">\(S\)</span>是信号平均功率，<spanclass="math inline">\(N\)</span>是噪声功率，<spanclass="math inline">\(B\)</span>是带宽，<spanclass="math inline">\(n_0\)</span>是噪声功率谱密度</p><p>设<span class="math inline">\(E_b=ST_b\)</span>是每比特能量，<spanclass="math inline">\(T_b=\frac{1}{B}\)</span>是每比特持续时间。 <spanclass="math display">\[C_t = B\log_2 (1 + \frac{ E_b/T_b }{n_0 B}) = B\log_2 (1 + \frac{ E_b}{n_0})\]</span></p><p>再来拍一张例题理解一下</p><figure><img src="/images/连续信道容量例题.jpg" title="连续信道容量例题"alt="连续信道容量例题" /><figcaption aria-hidden="true">连续信道容量例题</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>通信原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信笔记3</title>
    <link href="/2024/07/16/%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B03/"/>
    <url>/2024/07/16/%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B03/</url>
    
    <content type="html"><![CDATA[<h1 id="随机过程">随机过程</h1><h2 id="前言">前言</h2><p>随机过程（randomprocess）是非常重要的数学工具，用来描述信号与噪声的随机性。</p><h2 id="随机过程基本概念">随机过程基本概念</h2><p>单次测试接收机输出一个确定的时间函数<spanclass="math inline">\(x_i(t)\)</span>，它称为样本函数（Samplefunction）或随机过程的一次实现（realization）。全部样本函数构成的总体<spanclass="math inline">\(\left| x_1(t), x_2(t), x_3(t),~...~ ,~x_n(t)\right|\)</span>就是一个随机过程，记作<spanclass="math inline">\(\xi(t)\)</span>。随机过程是所有样本函数的集合（assemble）。</p><p>第二种定义：时间进程中处于不同时刻的随机变量的集合。在一个固定时刻<spanclass="math inline">\(t_1\)</span>上，不同样本的取值<spanclass="math inline">\({x_i(t_1), ~ i =1,2,3,...,n}\)</span>是一个随机变量，记为<spanclass="math inline">\(\xi(t_1)\)</span></p><h2 id="随机过程分布函数">随机过程分布函数</h2><p>任意时刻<span class="math inline">\(t_1\)</span>的<spanclass="math inline">\(\xi(t_1)\)</span>是一随机变量，其统计特性可以用分布函数或概率密度函数描述。把随机变量<spanclass="math inline">\(\xi(t_1) \leq x_1\)</span>的概率<spanclass="math inline">\(P[\xi(t_1) \leq x_1 ]\)</span>，记作 <spanclass="math display">\[F_1(x_1,t_1) = P[\xi(t_1) \leq x_1 ]\]</span> 并称他为随机过程<spanclass="math inline">\(\xi(t)\)</span>的一维分布函数</p><p><span class="math inline">\(F_1(x_1,t_1)\)</span>对<spanclass="math inline">\(x_1\)</span>的偏导 <span class="math display">\[\frac{ \partial F_1(x_1,t_1) }{ \partial x_1 } = f_1(x_1, t_1)\]</span> 称为<spanclass="math inline">\(\xi(t)\)</span>的一维概率密度函数。</p><p>以上分布函数或概率密度函数仅描述了随机过程在任一瞬间的统计特性，对随机过程的描述很不充分。进而对于任意固定的<spanclass="math inline">\(t_1,t_2\)</span>，把<spanclass="math inline">\(\xi(t_1) \leq x_1\)</span>和<spanclass="math inline">\(\xi(t_2) \leq x_2\)</span>同时成立的概率 <spanclass="math display">\[F_2(x_1, x_2; t_1, t_2) = P{\xi(t_1) \leq x_1, \xi(t_2) \leq x_2}\]</span> 称为随机过程<spanclass="math inline">\(\xi(t)\)</span>的二维分布函数。</p><p><span class="math inline">\(F_2(x_1, x_2; t_1, t_2)\)</span>对<spanclass="math inline">\(x_1,x_2\)</span>的偏导 <spanclass="math display">\[\frac{ \partial^2 F_2(x_1, x_2; t_1, t_2) }{ \partial x_1 \partial x_2 }= f_2(x_1, x_2; t_1, t_2)\]</span> 称为<spanclass="math inline">\(\xi(t)\)</span>的二维概率密度函数。</p><p>推广到n维，有 <span class="math display">\[F_n(x_1, x_2, x_3, ... , x_n; ~ t_1, t_2, t_3, ... , t_n) = P \left\{\xi(t_1) \leq x_1, \xi(t_2) \leq x_2, \xi(t_3) \leq x_3, ... ,\xi(t_n)\leq x_n \right\}\]</span> <span class="math display">\[\frac{ \partial^n F_n(x_1, x_2, x_3, ... , x_n; ~ t_1, t_2, t_3, ... ,t_n) }{ \partial x_1 \partial x_2 \partial x_3 ... \partial x_n } =f_n(x_1, x_2, x_3, ... , x_n; ~ t_1, t_2, t_3, ... , t_n)\]</span></p><h2 id="随机过程数字特征">随机过程数字特征</h2><h3 id="期望e">期望E</h3><p><span class="math display">\[E[\xi(t)] = \int_{-\infty}^{\infty} xf_1(x,t)dx\]</span> 期望函数是时间的确定函数，记为<spanclass="math inline">\(a(t)\)</span>，表示随机过程<spanclass="math inline">\(n\)</span>个样本函数曲线的摆动中心</p><h3 id="方差d">方差D</h3><p><span class="math display">\[D[\xi(t)] = E[(\xi(t) - a(t))^2] = E[\xi^2(t)] - a^2(t) =\int_{-\infty}^{\infty} x^2f_1(x,t)dx - [a(t)]^2\]</span></p><h3 id="相关函数">相关函数</h3><p>协方差函数 <span class="math display">\[B(t_1, t_2) = E \left\{ [ \xi(t_1) - a(t_1) ] [ \xi(t_2) - a(t_2) ]\right\} = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} [ x_1 -a(t_1) ] [ x_2 - a(t_2) ]f_2(x_1, x_2; t_1, t_2)dx_1 dx_2\]</span></p><p>自相关函数 <span class="math display">\[R(t_1, t_2) = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} x_1 x_2f_2(x_1, x_2; t_1, t_2)dx_1 dx_2 = B(t_1, t_2) + a(t_1)a(t_2)\]</span></p><p>互相关函数 <span class="math display">\[R_{\xi \eta}(t_1, t_2) = E[\xi(t_1)\eta(t_2)]\]</span></p><h2 id="平稳随机过程">平稳随机过程</h2><p>平稳随机过程：<spanclass="math inline">\(\xi(t)\)</span>的时间平移不影响其任何统计特性。</p><p>性质：</p><p>对任意的正整数<span class="math inline">\(n\)</span>和实数<spanclass="math inline">\(\Delta\)</span> <span class="math display">\[f_n(x_1, x_2, x_3, ... , x_n; ~ t_1, t_2, t_3, ... , t_n) = f_n(x_1,x_2, x_3, ... , x_n; ~ t_1+\Delta, t_2+\Delta, t_3+\Delta, ... ,t_n+\Delta)\]</span></p><p>一维概率密度函数与时间无关 <span class="math display">\[f_1(x_1, t_1) = f_1(x_1)\]</span></p><p>二维概率密度函数只与时间间隔<span class="math inline">\(\tau = t_2 -t_1\)</span>有关 <span class="math display">\[f_2(x_1,x_2; t_1, t_2) = f_2(x_1,x_2; \tau)\]</span></p><p>均值 <span class="math display">\[E[\xi(t)] = a\]</span></p><p>自相关函数 <span class="math display">\[R(t_1, t_2) = E[\xi(t_1)\xi(t_1 + \tau)] = R(\tau)\]</span></p><p>实际中使用</p><ol type="1"><li>均值与<span class="math inline">\(t\)</span>无关，为常数<spanclass="math inline">\(a\)</span></li><li>自相关函数只与时间间隔<span class="math inline">\(\tau\)</span>有关这两个条件判断随机过程的平稳性。</li></ol><p>同时满足条件1,2的过程定义为广义平稳随机过程</p><h3 id="各态经历性">各态经历性</h3><p>含义：随机过程中任一次实现都经历了随机过程的所有可能状态</p><p>时间均值 <span class="math display">\[\overline{a} = \overline{ x(t) } = \lim_{T-&gt;\infty} \frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}} x(t)dt\]</span></p><p>时间相关函数 <span class="math display">\[\overline{R(\tau)} = \overline{x(t)x(t+\tau)} = \lim_{T-&gt;\infty}\frac{1}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}} x(t)x(t+\tau) dt\]</span></p><p>平稳过程的统计平均值等于任意一次实现的时间平均值 <spanclass="math display">\[\left\{\begin{aligned}a &amp;= \overline{a} \\R(\tau) &amp;= \overline{R(\tau)}\end{aligned}\right.\]</span></p><p>好处：用一次实现的时间平均代替过程的统计平均</p><p>注意：具有各态经历的随机过程一定是平稳过程，反之不一定成立</p><h3 id="平稳过程自相关函数">平稳过程自相关函数</h3><p><span class="math display">\[R(\tau) = E[\xi(t)\xi(t+\tau)]\]</span></p><p>性质：</p><ol type="1"><li><span class="math inline">\(R(0) = E[\xi^2(t)]\)</span>，表示<spanclass="math inline">\(\xi(t)\)</span>的平均功率</li><li><span class="math inline">\(R(\tau) = R(-\tau)\)</span></li><li><span class="math inline">\(|R(\tau)| \leq R(0)\)</span></li><li><span class="math inline">\(R(\infty) = E^2[\xi(t)] =a^2\)</span>，表示<spanclass="math inline">\(\xi(t)\)</span>的直流功率</li><li><span class="math inline">\(R(0) - R(\infty) =\sigma^2\)</span>，<spanclass="math inline">\(\sigma^2\)</span>是方差，表示平稳过程<spanclass="math inline">\(\xi(t)\)</span>的交流功率</li></ol><h3 id="平稳过程功率谱密度">平稳过程功率谱密度</h3><p>对于任意的确定功率信号<span class="math inline">\(x(t)\)</span> <spanclass="math display">\[P_x(f) = \lim_{T-&gt;\infty} \frac{ \left| X_f(f) \right|^2 }{ T }\]</span> 式中<span class="math inline">\(X_f(f)\)</span>是<spanclass="math inline">\(x(t)\)</span>的截断函数<spanclass="math inline">\(x_T(t)\)</span>对应的频谱</p><p>某一样本的功率谱密度不能作为过程的功率谱密度。过程功率谱密度看作对所有样本的功率谱的统计平均<span class="math display">\[P_{\xi}(f) = E[P_x(f)]\]</span>非周期的功率型信号的自相关函数与其功率谱密度是一堆傅里叶变换。这种关系对平稳随机过程同样成立。维纳——辛钦定理<span class="math display">\[\begin{aligned}    P_{\xi}(f) = \int_{-\infty}^{\infty} R(\tau) e^{-j2\pi f\tau} d\tau\\    R(\tau) = \int_{-\infty}^{\infty} P_{\xi}(f) e^{j2\pi f\tau} df\end{aligned}\]</span></p><p>在维纳——辛钦的基础上，可以得到以下结论</p><ul><li>对功率谱密度进行积分得到平稳过程的平均功率 <spanclass="math display">\[R(0) = \int_{-\infty}^{\infty} P_{\xi}(f) df\]</span></li><li>各态经历过程的任一样本函数的功率谱密度等于过程的功率谱密度</li><li><span class="math inline">\(P_{\xi}(f)\)</span>具有非负性和实偶性<span class="math display">\[\begin{aligned}  P_{\xi}(f) \geq 0 \\  P_{\xi}(f) = P_{\xi}(-f)\end{aligned}\]</span></li></ul><h2 id="高斯随机过程">高斯随机过程</h2><p>定义：随机过程<spanclass="math inline">\(\xi(t)\)</span>的任意n维(n=1,2,3...)分布均服从正态分布。<span class="math display">\[f_n(x_1, x_2, x_3, ... , x_n; ~ t_1, t_2, t_3, ... , t_n) = \frac{1}{(2\pi)^{n/2} \sigma_1\sigma_2\sigma_3...\sigma_n | \boldsymbol{B} |^{1/2}} exp \left[ \frac{-1}{2|\boldsymbol{B}|} \sum_{j=1}^n\sum_{k=1}^n \left|\boldsymbol{B}\right| _{jk} \left( \frac{x_j - a_j}{\sigma_j } \right) \left( \frac{x_k - a_k}{ \sigma_k } \right)  \right]\]</span></p><p>式中<span class="math inline">\(a_k = E[\xi(t_k)], \sigma_k^2 =E[\xi(t_k) - a_k]^2\)</span>；<spanclass="math inline">\(\boldsymbol{B}\)</span>为归一化协方差矩阵的行列式</p><p><span class="math display">\[|\boldsymbol{B}| = \begin{vmatrix}    1 &amp; b_{12} &amp; ... &amp; b_{1n} \\    b_{21} &amp; 1 &amp; ... &amp; b_{2n} \\    \vdots &amp; \vdots &amp; \cdots &amp; \vdots \\    b_{n1} &amp; b_{n2} &amp; ... &amp; 1\end{vmatrix}\]</span></p><p><span class="math display">\[b_{jk} = \frac{ E \left\{ [\xi(t_j) - a_j] [\xi(t_k) - a_k]\right\}  }{\sigma_j \sigma_k}\]</span></p><h3 id="重要性质">重要性质</h3><ol type="1"><li>高斯过程的n维分布只依赖各个随机变量的均值、方差和归一化协方差。</li><li>广义平稳的高斯过程是严平稳的</li><li>如果高斯过程在不同时刻的取值是不相关的，即对所有<spanclass="math inline">\(j \neq k\)</span>，<spanclass="math inline">\(b_{jk} = 0\)</span> <span class="math display">\[f_n(x_1, x_2, x_3, ... , x_n; ~ t_1, t_2, t_3, ... , t_n) =f(x_1,t_1)\cdot f(x_2,t_2)\cdot f(x_3,t_3)\cdot \cdots \cdot f(x_n,t_n)\]</span></li><li>高斯过程经过线性变换后仍然是高斯过程。线性系统的输入为高斯过程，输出也是高斯过程。</li></ol><h3 id="高斯随机变量">高斯随机变量</h3><p>高斯随机变量一维概率密度函数为 <span class="math display">\[f(x) = \frac{1}{ \sqrt{2\pi}\sigma } \exp( - \frac{(x-a)^2}{2\sigma^2} )\]</span> <spanclass="math inline">\(a=0,\sigma=1\)</span>时变成标准化正态分布。</p><p>计算<span class="math inline">\(P(\xi \leq x)\)</span> <spanclass="math display">\[F(x) = P(\xi \leq x) = \int_{-\infty}^x \frac{1}{\sqrt{2\pi}\sigma} \exp\left[ - \frac{(z-a)^2}{2\sigma^2} \right] dz\]</span> 令<span class="math inline">\(t =(z-a)/\sqrt{2}\sigma\)</span>则 <span class="math display">\[F(x) = \frac{1}{2} + \frac{1}{2} erf\left( \frac{(x-a)}{\sqrt{2}\sigma}\right)\]</span> <span class="math inline">\(erf\)</span>表示误差函数 <spanclass="math display">\[erf(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{-t^2} dt\]</span> 互补误差函数<span class="math inline">\(erfc\)</span> <spanclass="math display">\[erfc(x) = 1-erf(x)\]</span></p><p><span class="math inline">\(Q(x)\)</span>用于表示高斯曲线尾部下的面积<span class="math display">\[Q(x) = \frac{1}{\sqrt{2\pi}} \int_x^{\infty} e^{-t^2/2} dt ~~~~ x \geq 0\]</span> <span class="math inline">\(Q(x)\)</span>和<spanclass="math inline">\(erfc\)</span>比较 <span class="math display">\[\begin{aligned}    Q(x) = \frac{1}{2} erfc(\frac{x}{\sqrt{2}}) \\    erfc(x) = 2Q(\sqrt{2}x)\end{aligned}\]</span></p><h2 id="平稳随机过程通过线性系统">平稳随机过程通过线性系统</h2><p>使用下式描述输入随机过程<spanclass="math inline">\(\xi_i(t)\)</span>经过线性系统后的输出随机过程<spanclass="math inline">\(\xi_o(t)\)</span> <span class="math display">\[\xi_o(t) = \int_{-\infty}^{\infty} h(\tau)\xi_i(t-\tau) d\tau\]</span></p><h3 id="输出过程均值">输出过程均值</h3><p>输出过程<span class="math inline">\(\xi_o(t)\)</span>均值 <spanclass="math display">\[E[\xi_o(t)] = E\left[ \int_{-\infty}^{\infty} h(\tau)\xi_i(t-\tau) d\tau\right] = \int_{-\infty}^{\infty} h(\tau) E\left[ \xi_i(t-\tau) \right]d\tau\]</span> 因为是平稳随机过程，所以<span class="math inline">\(E\left[\xi_i(t-\tau) \right] = E\left[ \xi_i(t) \right] = a\)</span> <spanclass="math display">\[E[\xi_o(t)] = a \cdot \int_{-\infty}^{\infty} h(\tau) d\tau = a\cdotH(0)\]</span> <span class="math inline">\(H(0)\)</span>是线性系统在<spanclass="math inline">\(f=0\)</span>处的频率响应，即直流增益</p><h3 id="输出过程自相关函数">输出过程自相关函数</h3><p>课本上公式不会推，直接摆结论吧[doge] <span class="math display">\[R_o(t_1, t_1+\tau) = R_o(\tau)\]</span></p><h3 id="输出过程功率谱密度">输出过程功率谱密度</h3><p><span class="math display">\[P_o(f) = |H(f)|^2 P_i(f)\]</span></p><h3 id="输出过程概率分布">输出过程概率分布</h3><p>结论：高斯过程经过线性变换后的过程仍为高斯过程</p><h2 id="窄带随机过程">窄带随机过程</h2><p>定义：随机过程<spanclass="math inline">\(\xi(t)\)</span>的谱密度集中在中心频率<spanclass="math inline">\(f_c\)</span>附近相对窄的范围<spanclass="math inline">\(\Delta f\)</span>内，<spanclass="math inline">\(\Delta f \ll f_c\)</span>，且<spanclass="math inline">\(f_c\)</span>远离0频率。</p><p>窄带随机过程<span class="math inline">\(\xi(t)\)</span>表示为 <spanclass="math display">\[\xi(t) = a_{\xi}(t) \cos[w_c t + \phi_{\xi}(t)] ~~~~ a_{\xi}(t) \geq 0\]</span> 式中<spanclass="math inline">\(a_{\xi}(t)\)</span>是随机包络，<spanclass="math inline">\(\phi_{\xi}(t)\)</span>是随机相位，<spanclass="math inline">\(w_c\)</span>是中心角频率</p><h3 id="平稳窄带随机过程">平稳窄带随机过程</h3><p>将窄带随机过程变形成同相分量-正交分量表达式 <spanclass="math display">\[\xi(t) = \xi_c(t)cos(w_ct) - \xi_s(t)sin(w_ct)\]</span> <span class="math display">\[\xi_c(t) = a_{\xi}(t)cos(\phi_{\xi}(t)),~~~~ \xi_s(t) =a_{\xi}(t)sin(\phi_{\xi}(t))\]</span></p><h3 id="同相分量和正交分量的统计特性">同相分量和正交分量的统计特性</h3><p><spanclass="math inline">\(\xi(t)\)</span>是平稳高斯窄带过程，均值为0，方差为<spanclass="math inline">\(\sigma_{\xi}^2\)</span> <spanclass="math display">\[\xi(t) = \xi_c(t)cos(w_ct) - \xi_s(t)sin(w_ct)\]</span></p><p>结论：</p><ul><li><span class="math inline">\(\xi_c(t)\)</span>和<spanclass="math inline">\(\xi_s(t)\)</span>的数学期望均为0；<spanclass="math inline">\(E[\xi_c(t)] = E[\xi_s(t)]=0\)</span></li><li><span class="math inline">\(\xi_c(t)\)</span>和<spanclass="math inline">\(\xi_s(t)\)</span>的相关函数均只与时间间隔有关，平稳</li><li><span class="math inline">\(\xi_c(t)\)</span>和<spanclass="math inline">\(\xi_s(t)\)</span>的自相关函数相同</li><li><span class="math inline">\(\xi_c(t)\)</span>和<spanclass="math inline">\(\xi_s(t)\)</span>的方差相同：<spanclass="math inline">\(\sigma_{\xi}^2 = \sigma_{c}^2 =\sigma_{s}^2\)</span></li><li><span class="math inline">\(\xi_c(t)\)</span>和<spanclass="math inline">\(\xi_s(t)\)</span>是互不相关，统计独立的高斯变量</li></ul><h2 id="随机包络和随机相位的统计特性">随机包络和随机相位的统计特性</h2><p>随机包络<spanclass="math inline">\(a_{\xi}(t)\)</span>的统计特性：</p><ul><li>服从瑞利分布 <span class="math display">\[f(a_{\xi}) = \frac{a_{\xi}}{\sigma_{\xi}^2} \exp \left[ -\frac{a_{\xi}^2}{2 \sigma_{\xi}^2}  \right] ~~~~ a_{\xi} \geq 0\]</span></li></ul><p>随机相位<spanclass="math inline">\(\phi_{\xi}(t)\)</span>的统计特性</p><ul><li>服从均匀分布 <span class="math display">\[f(\phi_{\xi}) = \frac{1}{2\pi} ~~~~ 0 \leq \phi_{\xi} \leq 2\pi\]</span></li></ul><p>随机相位和随机包络统计独立 <span class="math display">\[f(a_{\xi}, \phi_{\xi}) = f(a_{\xi})\cdot f(\phi_{\xi})\]</span></p><h2 id="正弦波加窄带高斯噪声">正弦波加窄带高斯噪声</h2><p>正弦波加窄带高斯噪声混合信号可以这样描述： <spanclass="math display">\[r(t) = A\cos(w_c t + \theta) + n(t)\]</span> 式中<span class="math inline">\(n(t) = n_c(t)\cos(w_c t) +n_s(t)\sin(w_c t)\)</span>是窄带高斯噪声，均值为0，方差为<spanclass="math inline">\(\sigma_n^2\)</span>；<spanclass="math inline">\(\theta\)</span>是正弦波的随机相位在<spanclass="math inline">\((0,2\pi)\)</span>上均匀分布。振幅<spanclass="math inline">\(A\)</span>和<spanclass="math inline">\(w_c\)</span>是确知量。</p><p><span class="math display">\[\begin{aligned}r(t) &amp;= [A\cos\theta + n_c(t)] \cos w_c t - [A\sin\theta +n_s(t)]\sin w_c t \\&amp;= z_c(t)\cos w_c t - z_s(t)\sin w_c t\end{aligned} \tag{1}\]</span></p><p>对式(1)合并 <span class="math display">\[r(t) = z(t)\cos [w_c t + \phi(t)]\]</span></p><p>随机包络 <span class="math display">\[z(t) = \sqrt{ z_c^2(t)  + z_s^2(t)}\]</span></p><p>随机相位 <span class="math display">\[\phi(t) = \arctan \frac{z_s(t)}{z_c(t)}\]</span></p><h3 id="同相分量和正交分量统计特性">同相分量和正交分量统计特性</h3><p>随机相位<span class="math inline">\(\theta\)</span>给定时，<spanclass="math inline">\(z_c(t)\)</span>，<spanclass="math inline">\(z_s(t)\)</span>是不相关，相互独立，且同分布的高斯变量。其数字特征：</p><ul><li><span class="math inline">\(E[z_c(t)] = A\cos \theta\)</span></li><li><span class="math inline">\(E[z_s(t)] = A\sin \theta\)</span></li><li><span class="math inline">\(\sigma_n^2 = \sigma_c^2 =\sigma_s^2\)</span></li></ul><h3id="随机包络和随机相位的统计特性-1">随机包络和随机相位的统计特性</h3><p>随机包络<span class="math inline">\(z(t)\)</span>的统计特性：</p><p>服从莱斯分布/广义瑞利分布 <span class="math display">\[f(z) = \frac{z}{\sigma_n^2} \exp \left( - \frac{z^2 + A^2}{ 2\sigma_n^2} \right) I_0 \left( \frac{Az}{\sigma_n^2} \right), ~~~~ z\geq 0\]</span> <span class="math display">\[I_0(x) = \frac{1}{2\pi} \int_0^{2\pi} \exp[x\cos \phi ] d \phi\]</span></p><ul><li>大信噪比环境：<span class="math inline">\(r =\frac{A^2}{2\sigma_n^2} \gg 1\)</span></li><li>小信噪比环境：<spanclass="math inline">\(A-&gt;0\)</span>退化为瑞利分布</li></ul><p>随机相位<span class="math inline">\(\phi(t)\)</span>的统计特性</p><ul><li>小信噪比环境：<spanclass="math inline">\(f(\phi)\)</span>均匀分布</li><li>大信噪比环境：集中在有用信号相位附近，在0相位附近取值集中</li></ul><figure><img src="/images/正弦波高斯噪声.png"title="总结https://www.bilibili.com/video/BV1wA4y1f7Co?p=10"alt="总结https://www.bilibili.com/video/BV1wA4y1f7Co?p=10" /><figcaptionaria-hidden="true">总结https://www.bilibili.com/video/BV1wA4y1f7Co?p=10</figcaption></figure><p>“窄带过程”和”正弦波+高斯窄带过程“两类模型有关结论常用于分析系统抗噪声性能。结合误差函数、互补误差函数的定义可以求解系统的总误码率</p><h2 id="高斯白噪声和带限白噪声">高斯白噪声和带限白噪声</h2><p>白噪声<spanclass="math inline">\(n(t)\)</span>：噪声的功率谱密度在所有频率上均为一常数<span class="math display">\[P_n(f) = \frac{n_0}{2} ~~~~ (-\infty &lt; f &lt; \infty) ~~ (W/Hz)\tag{2}\]</span> 或者 <span class="math display">\[P_n(f) = n_0 ~~~~ (0 &lt; f &lt; \infty) ~~ (W/Hz) \tag{3}\]</span> 式中<span class="math inline">\(n_0\)</span>是正的常数。</p><p>式(2)是双边功率谱密度，式(3)是单边功率谱密度</p><p>对式(2)作傅里叶反变换，得到白噪声的自相关函数 <spanclass="math display">\[R(\tau) = \frac{n_0}{2} \delta(\tau)\]</span> 白噪声仅在<spanclass="math inline">\(\tau=0\)</span>时候才相关，任意两个时刻随机变量都不相关。</p><p>白噪声带宽无限，平均功率<spanclass="math inline">\(R(0)\)</span>无穷大。</p><p>工程上，热噪声带宽大于系统带宽，可以把热噪声视为白噪声。</p><p>如果白噪声取值的概率分布服从高斯分布，则称为高斯白噪声（常用噪声模型）。</p><h3 id="低通白噪声">低通白噪声</h3><p>低通白噪声：白噪声通过理想矩形的低通滤波器，输出的噪声为低通白噪声。也用<spanclass="math inline">\(n(t)\)</span>表示。设截止频率<spanclass="math inline">\(f_H\)</span></p><p><span class="math display">\[P_n(f) = \left\{\begin{aligned}    \frac{n_0}{2} ~~~~ |f| \leq f_H \\    0 ~~~~~~~~~~~~ 其它\end{aligned}\right.\]</span></p><p>其自相关函数： <span class="math display">\[R(\tau) = n_0 f_H \frac{ \sin 2\pi f_H \tau }{ 2\pi f_H \tau }\]</span></p><p>这种噪声也称为带限白噪声。只有在<span class="math inline">\(\tau =k/2\pi (k =1,2,3,\cdots)\)</span>上得到的随机变量才不相关。如果按抽样定理对带限白噪声进行抽样，抽样值是互不相关的随机变量。</p><h3 id="带通白噪声">带通白噪声</h3><p>带通白噪声：白噪声通过理想矩形的带通滤波器，输出的噪声为带通白噪声。</p><p><span class="math display">\[P_n(f) = \left\{\begin{aligned}    \frac{n_0}{2} ~~~~ f_c - \frac{B}{2} \leq |f| \leq f_c + \frac{B}{2}\\    0 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 其它\end{aligned}\right.\]</span></p><p>自相关函数 <span class="math display">\[R(\tau) = n_0 B \frac{ \sin \pi B \tau }{ \pi B \tau } \cos 2\pi f_c\tau\]</span></p><p>通常<span class="math inline">\(B \llf_c\)</span>，因此带通滤波器也称窄带滤波器，相应的带通白噪声称为窄带高斯白噪声。它的表达式和前文一般窄带随机过程相同<span class="math display">\[n(t) = n_c(t) \cos w_c t - n_s(t) \sin w_c t\]</span> <span class="math display">\[E[n(t)] = E[n_c(t)] = E[n_s(t)] = 0\]</span> <span class="math display">\[\sigma_n^2 = \sigma_c^2 = \sigma_s^2\]</span></p><p>平均功率：<span class="math inline">\(N = n_0 B\)</span></p>]]></content>
    
    
    <categories>
      
      <category>通信原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信笔记2</title>
    <link href="/2024/07/16/%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B02/"/>
    <url>/2024/07/16/%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<p>功率信号频谱表达式： <span class="math display">\[C_n = \frac{1}{T_0} \int_{-T_0/2}^{T_0/2} s(t) e^{-j2\pi nf_0 t} dt\]</span> 能量信号频谱表达式： <span class="math display">\[\begin{aligned}S(f) = \int_{-\infty}^{\infty} s(t) e^{-j2\pi f t} dt \\s(t) = \int_{-\infty}^{\infty} S(f) e^{j2\pi f t} df\end{aligned}\]</span> 能量信号能量谱密度：</p><p>总能量： <span class="math display">\[E = \int_{-\infty}^{\infty} s^2(t) dt = \int_{-\infty}^{\infty} \left|S(f) \right|^2 df\]</span> 能量谱密度： <span class="math display">\[\left| S(f) \right|^2\]</span></p><p>功率信号功率谱密度：</p><p>能量： <span class="math display">\[E = \int_{-T/2}^{T/2} s_T^2(t) dt = \int_{-\infty}^{\infty} \left|S_T(f) \right|^2 df\]</span> 功率谱密度： <span class="math display">\[\lim_{T-&gt;\infty} \frac{1}{T} \left| S_T(f) \right|^2 = P(f)\]</span> 信号功率： <span class="math display">\[P = \int_{-\infty}^{\infty} P(f) df\]</span> 若有周期性<span class="math inline">\(T_0\)</span>： <spanclass="math display">\[P = \frac{1}{T_0} \int_{-T_0/2}^{T_0/2} s^2(t) dt = \sum_{n =-\infty}^{\infty} \left| C_n \right|^2\]</span> <span class="math inline">\(C_n\)</span>是傅里叶级数系数</p>]]></content>
    
    
    <categories>
      
      <category>通信原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信笔记1</title>
    <link href="/2024/07/16/%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B01/"/>
    <url>/2024/07/16/%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h1 id="信息">信息</h1><p>信息定义：消息中蕴含的内容，原来未知而待知的内容。</p><p>通信目标：利用电信号传输消息中包含的信息，收端获得信息后，不确定性被消除。</p><p>一般通信系统模型：</p><ul><li><p>信源-&gt;发送设备-&gt;信道-&gt;接收设备-&gt;信宿</p></li><li><p>噪声源-&gt;信道</p></li></ul><p>数字通信系统模型：</p><ul><li><p>信源-&gt; 信源编码 -&gt; 加密 -&gt; 信道编码 -&gt; 数字调制-&gt;信道-&gt; 数字解调-&gt; 信道译码-&gt; 解密-&gt; 信源译码-&gt;信宿</p></li><li><p>噪声源-&gt;信道</p></li></ul><p>信源编码：A/D转换，通过数据压缩去冗余，提高通信系统有效性。</p><p>信道编码：提高系统抗干扰能力。</p><h2 id="信息量">信息量</h2><p>对接收者来说，只有消息中不确定的内容才构成信息。信息量的多少与接收者收到消息时感到的惊讶程度有关。</p><p>消息所表达的事件越不可能发生、越不可预测，信息量越大。</p><p>设<span class="math inline">\(P(x)\)</span>表示消息发生的概率，<spanclass="math inline">\(I\)</span>表示消息中所含的信息量 <spanclass="math display">\[I = I[P(x)]\]</span></p><p><span class="math inline">\(I\)</span>的两个特性：</p><ul><li><span class="math inline">\(P(x)\)</span>减小，<spanclass="math inline">\(I\)</span>增大。<spanclass="math inline">\(P(x)=1,~~~I=0;~~~~~~P(x)=0,~~~I=\infty\)</span></li><li><span class="math inline">\(I[P(x_1)P(x_2)P(x_3)...] = I[P(x_1)] +I[P(x_2)] + I[P(x_3)] + ...\)</span></li></ul><p><span class="math inline">\(I\)</span>的表达式：<spanclass="math inline">\(I = \log_a \frac{1}{P(x)} = - \log_aP(x)\)</span></p><p>信息量的单位和式中对数的底<spanclass="math inline">\(a\)</span>有关。若<spanclass="math inline">\(a=2\)</span>，则信息量的单位为比特（<spanclass="math inline">\(bit\)</span>）简记为<spanclass="math inline">\(b\)</span>。若<spanclass="math inline">\(a=e\)</span>，则信息量的单位为奈特（<spanclass="math inline">\(nat\)</span>）。</p><h2 id="等概率离散消息度量">等概率离散消息度量</h2><p>有一离散信源，以相等概率发送二进制数字“0”，“1”，则每个数字信息量为<span class="math display">\[I(0) = I(1) = \log_2 \frac{1}{1/2} = 1 ~ (b)\]</span> 一个二进制码元称为1b。</p><p>同理，传送等概率四进制波形之一（<spanclass="math inline">\(P=1/4\)</span>）的信息量为<spanclass="math inline">\(2b\)</span>， 传送等概率八进制波形之一（<spanclass="math inline">\(P=1/8\)</span>）的信息量为<spanclass="math inline">\(3b\)</span>， 传送等概率<spanclass="math inline">\(M\)</span>进制波形之一（<spanclass="math inline">\(P=1/M\)</span>）的信息量为<spanclass="math inline">\(\log_2 M ~~ (b)\)</span>。</p><p>考虑非等概率情况：<span class="math inline">\(x_i~(i =1,2,3...M)\)</span>对应<span class="math inline">\(P(x_i)~(i =1,2,3...M)\)</span>。且<span class="math inline">\(\sum_{i=1}^M P(x_i) =1\)</span>。 <span class="math display">\[I(x_i) = -\log_2 P(x_i)\]</span></p><p>每个符号所含信息量的统计平均值，即平均信息量为： <spanclass="math display">\[H(x) = -\sum_{i=1}^M P(x_i)\log_2 P(x_i) ~~~~ (b/符号)\]</span> 由于<spanclass="math inline">\(H\)</span>同热力学中的熵的形式相似，故常称他为信息源的熵，单位为“<spanclass="math inline">\(b/符号\)</span>”</p><p>显然，<spanclass="math inline">\(P(x_i)=\frac{1}{M}\)</span>时，熵有最大值。</p><p>一般用平均信息量（熵）乘某条消息的符号总数计算该条消息的信息量。</p><p>连续消息的平均信息量为： <span class="math display">\[H(x) = -\int_{-\infty}^{\infty} f(x) \log_a f(x) dx\]</span> <spanclass="math inline">\(f(x)\)</span>为连续消息出现的概率密度。</p><h1 id="通信系统的性能指标">通信系统的性能指标</h1><table><thead><tr class="header"><th></th><th>有效性</th><th>可靠性</th></tr></thead><tbody><tr class="odd"><td>模拟通信</td><td>传输带宽</td><td>输出信噪比</td></tr><tr class="even"><td>数字通信</td><td>码元速率<span class="math inline">\(R_B\)</span></td><td>差错概率（误码率）</td></tr><tr class="odd"><td></td><td>信息速率<span class="math inline">\(R_b\)</span></td><td>差错概率（误信率）</td></tr><tr class="even"><td></td><td>频带利用率<span class="math inline">\(\eta\)</span></td><td></td></tr></tbody></table><p>频带利用率： <span class="math inline">\(\eta = R_B/B ~~(Baud/Hz)\)</span>，或者，<span class="math inline">\(\eta_b = R_b/B ~~(b/(s\cdot Hz))\)</span></p><p><spanclass="math inline">\(R_B\)</span>是码元传输速率（传码率），单位时间传输码元数目，单位（<spanclass="math inline">\(Baud\)</span>）。 <spanclass="math inline">\(R_b\)</span>是信息传输速率（传信率），单位时间传输平均信息量，单位（<spanclass="math inline">\(b/s\)</span>）。</p><p><span class="math inline">\(M\)</span>进制码元携带<spanclass="math inline">\(\log_2 M\)</span>比特的信息量： <spanclass="math display">\[\begin{aligned}R_b &amp;= R_B \log_2 M ~~(b/s) \\R_B &amp;= R_b / \log_2 M ~~(Baud)\end{aligned}\]</span></p><p>可靠性：</p><ul><li>模拟：接收端输出信号与噪声功率比（<spanclass="math inline">\(S/N\)</span>）</li><li>数字：用差错概率衡量（误码率、误信率）</li></ul><p>误码率： <span class="math display">\[P_e = \frac{错误码元数量}{传输总码元数量}\]</span></p><p>误信率： <span class="math display">\[P_b = \frac{错误比特数量}{传输总比特数量}\]</span></p><p>当使用二进制编码时，<span class="math inline">\(P_e =P_b\)</span></p><p>使用八进制编码时，码元有三位，假设收到<spanclass="math inline">\(9bit\)</span>，错<spanclass="math inline">\(1bit\)</span>，即收到三个符号，错一个符号。这种情况下，<spanclass="math inline">\(P_e=1/3, ~~ P_b = 1/9, ~~ P_e &gt;P_b\)</span></p>]]></content>
    
    
    <categories>
      
      <category>通信原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>狼与香辛料</title>
    <link href="/2024/07/15/%E7%8B%BC%E4%B8%8E%E9%A6%99%E8%BE%9B%E6%96%99/"/>
    <url>/2024/07/15/%E7%8B%BC%E4%B8%8E%E9%A6%99%E8%BE%9B%E6%96%99/</url>
    
    <content type="html"><![CDATA[<h1 id="狼与香辛料经典台词">狼与香辛料经典台词</h1><p>原帖 http://tieba.baidu.com/p/2204474771 作者：KINGERSHA（选取其中的一些粘在这里保留收藏）（粘完回来PS一下，赫萝和罗伦斯之间是纯爱，不要想歪0.0）</p><p>「わっちは神と呼ばれて长いことこの土地に缚《しば》られていたがよ、神なんてほど伟いもんじゃありんせん。わっちゃあホロ以外の何者でもない」</p><p>「虽然咱长久以来被尊为神，且被束缚在这块土地上，但咱根本不是什么伟大的神。咱就是咱.咱是赫萝。」</p><p>「旅はする前が一番楽しく、犬は鸣き声だけが一番怖く、女は后ろ姿が一番美しいものでありんす。気軽にひょいとめくれば人の梦を壊《こわ》しんす。わっちにゃそんなことできんせん」</p><p>「旅行唯有出发前最愉快，狗儿唯有叫声最吓人，女人唯有背影最美丽。随随便便抛头露面，会坏了人家的美梦，这种事情咱做不来。」</p><p>「そんなやけどはわっちの证《あかし》。この尻尾《しっぽ》と耳と同じ。二つとないわっちの证と思うまでよ」</p><p>「如果睑上有灼伤，那也属于咱。就像咱的耳朵和尾巴一样，都是独一无二的证明。」</p><p>「嘘をつく时、大事なのはその嘘《うそ》は嘘の内容ではなく、なぜ嘘をつくかというその状况じゃ」</p><p>「说谎的时候，重点不在于说谎的内容，而在于为何要说谎。」</p><p>「林檎……食べ……たいん……じゃが……」</p><p>「咱……想要……吃……苹果.]</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词 <wbr>原版加翻译（1）</p><p>「林檎は悪魔の実じゃ。わっちらをそそのかす甘《あま》い诱惑に満ちておる」</p><p>[苹果是恶魔的果实，充满诱惑咱们的香甜味道。」</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词 <wbr>原版加翻译（1）</p><p>「なに、気にすることはない。雄《おす》どもは皆｜阿呆《あほ》の妬き饼《もち》焼きじゃからの」</p><p>「哎，没什么好在意的，所有雄性都是爱吃醋的傻瓜呐。」</p><p>「さて、ぬしは思考の迷路にて右往左往しているようじゃ。そういう时は新たな视点を入れるべきじゃ。わっちらも获物を获る时、たまには木に登る。木の上から见る森はまた违うもの。つまりの」</p><p>「看来汝好像徘徊在思考的迷宫中走不出来，这时候应该让自己有新的观点·咱们想要猎取猎物时，时而会爬到树上去·从树上望去的森林又是不同的样貌，也就是说……]</p><p>「気が一本｜枯《か》れるところを见れば、それだけを见るなら森にとって害のような気もするが、森全体から见ればその木が栄养になって他《ほか》の木がよく育つのじゃから森のためになる。目の前のできごとが别の视点から见ればひっくり返ることはよくあること。どうじゃ、何か见えてこんかや？」</p><p>「如果只注意森林里的一株枯树，会觉得这株枯树对森林有害；但如果以整体森林来看，这株枯树会成为提供其他树木成长的养分来源，那就是对森林有益。如果用不同的观点来观察眼前的状况，经常会发现完全相反的事实。如何?有看到什么吗?」</p><p>「雄《おす》が肉を咥《くわ》えてやってきた时は、肉を取られそうな时より注意しろと言うからの」</p><p>「俗话说，当雄性叼着肉前来示好时，必须比自己的肉要被抢走时还要谨慎呐。」</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词 <wbr>原版加翻译（1）</p><p>「もう、目を覚まして谁もおらんのはいやじゃ……。一人は饱《あ》いた。一人は寒い。一人は……寂しい」</p><p>「咱不想再碰到醒过来时，都见不到人的状况了……咱受够孤独了。孤独好冷。孤独……好让人寂寞。」</p><p>「一人は饱《あ》きた」</p><p>「咱不想再一个人了。」</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词<wbr>原版加翻译（1）「孤独は死に至る病じゃ。十分钓り合う」</p><p>「孤独可是要人命呐，这划算极了。」</p><p>「わっちはあそこの土地に居着いて何年｜経《た》つかわからん。尻尾《しっぽ》の毛の数ほどおったかもしれん」</p><p>「咱不知道在那块土地待了乡长的岁月，或许有咱尾巴毛的数量那么多年。」</p><p>「もし、もし并んたら？」</p><p>「万一、万一有摆出来呢?」</p><p>「ぬしよ、约束じゃそ。よいな？」</p><p>「汝啊，要守承诺呐。恩?」</p><p>「普通、どの动物も寝てようが起きてようがさして変わらぬ。ぬしら人间が寝てる时に无防备すぎるだけじゃ」</p><p>「一般说来，动物不管是在睡觉还是醒著都差不了太多，唯独人类睡觉时太没警觉性罢了。」</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词 <wbr>原版加翻译（1）</p><p>叔：「あの羊饲い、どう思う？」</p><p>「你觉得那个牧羊人怎么样?」</p><p>狼：「わっちのほうが可爱《かわい》い」</p><p>「咱比较可爱。」</p><p>叔：「そうじゃなくて、腕前のことだ」</p><p>「我指的不是这个，我是说工夫怎么样?」</p><p>狼：「わっちがおるじゃないかや」</p><p>「不是有咱在吗?」</p><p>叔：「色香になど惑《まど》わされちゃいない。お前のほうが可爱《かわい》いからな」</p><p>「我没有被女色诱惑，因为你比较可爱啊。」</p><p>「うむ。わっちは可爱《かわい》いからの。一人にしておいたら危ない」</p><p>「恩。谁叫咱长得这么可爱呐，留咱一个人太危险了。」</p><p>「けど、雄《おす》はいつもそうじゃ。口ではなんとでも言う」</p><p>「可是，雄性每次都这样，嘴里说得可好听。」</p><p>「しかし、手伤を负った獣《けもの》は骨まで食われるのが相场というもの。ぬしは甘んじるのかや」</p><p>「可是，受了伤的动物往往会落得尸骨无存的下场，汝是不是想得太美好了?」</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词 <wbr>原版加翻译（1）</p><p>「旅の道连れが苦境に立たされておるというのに、のんびり宿で毛づくろいができるような不义理な狼《オオカミ》にわっちが见えるかや」</p><p>「咱像是看著旅伴陷入苦境，还能够悠哉地梳理尾巴的不重情义的狼吗?」</p><p>「じゃが、まあ、ぬしがお人好しじゃからわっちゃあ畅気《のんき》な旅ができているんじゃからな、すべてを望むのは赘沢《ぜいたく》というものかも知れぬ」</p><p>「不过，话说回来，因为汝是个烂好人，所以咱才能够悠哉地旅行。也许，什么都想拥有是太贪心了点。」</p><p>「そうじゃな。しかし、ぬしはもっとでかい罠《わな》に尻《しり》まで引っかかっとる最中じゃろ。わっちは罠にはまった兎《ウサギ》など狩りんせん。それはあまりにもか弱い」</p><p>「也是呗。不过，汝现在一屁股坐进了更大的陷阱里。咱没兴趣狩猎掉进陷阱的兔子，因为对手太弱了。」</p><p>「中途半端な贤さは死を招きんす」</p><p>「半吊子的聪明只会招来死亡。」</p><p>「身の程をわきまえぬ犬ほど腹の立つものはない」</p><p>[没有什么比搞不清楚自己身份的狗更教人生气的了.]</p><p>「なぜなら、夜になれば狼《オオカミ》は常に现れるからじゃ。目の前に、こんな可爱《かわい》い兎《ウサギ》がおるんじゃからの。毎晩狼に食べられる兎が、狼のことを知らぬわけがあるまい？」</p><p>「因为一到了夜晚，狼就会出现，毕竟这么可爱的兔子就近在眼前呐。每天晚上会被狼吞进肚子里的兔子，怎可能不了解狼呢?」</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词 <wbr>原版加翻译（1）</p><p>「つまりの、たまにはそっけなくしなければならぬ。それがよき手纲《たづな》となる」</p><p>「也就是说呐，偶尔得表现冷淡一些，才是好的驾驭法。」</p><p>「安い意地。粗《そ》末《まつ》な夸り。どれも若造が大事にするものじゃ」</p><p>「廉价的自尊、粗劣的傲气，无论哪个后生小辈都很重视这些东西。」</p><p>「ぬしがいい雄《おす》じゃったらここでロづけでもするんじゃがのう」</p><p>「汝要是个好雄性，这时候就应该要亲吻咱。」[转]整理小说《狼与香辛料》中萌狼经典的台词<wbr>原版加翻译（1）</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词 <wbr>原版加翻译（1）</p><p>「ぬしよ、わっちはこの计画がうまくいかぬとぬしと畅気《のんき》な旅ができぬと、そう思った。それはわっちにとって実に寂《さび》しい事态じゃ。じゃからの、わっちは我《が》慢《まん》した。事を穏便《おんびん》に済ませ、すばやくぬしと合流し、さっさと暖炉の前で温かいスープとジャガイモにありつこうと思って我慢した。わっちゃあヨイツの贤狼《けんろう》ホロじゃ。若造の仿慢《ごうまん》さくらい軽く许すことができる……」</p><p>「汝啊，如果这个计划没有成功，咱就不能和汝悠哉地旅行；对咱而言，这样子太叫人感伤了。所以咱忍下来。咱一心想要和平地解决事情，赶紧和汝会合，然后在暖炉前面喝热汤、吃马铃薯，所以忍了下来。咱是约伊兹的贤狼赫萝呐，咱可以轻松原谅后生小辈的傲慢态度……」</p><p>『背中から落ちたら口で咥《くわ》えていくからの』</p><p>『如果汝从咱背上掉下来，咱就用嘴巴叼著汝走。』</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词 <wbr>原版加翻译（1）</p><p>『うふふふ。い、や、じゃ』</p><p>呵呵呵，咱、不、要。』</p><p>「ぬしはこういうわっちが好きなんじゃろ？」</p><p>「汝喜欢这样的咱，是呗?」</p><p>「たわけが。阿呆《あほう》な雄《おす》ほどか弱いのが好きじゃからな。か弱いのはぬしらの头のほうじゃと気がつかぬ」</p><p>「大笨驴。越是愚蠢的雄性，就越喜欢软弱的雌性，根本没自觉到真正软弱的是汝等雄性的脑袋瓜。」</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词 <wbr>原版加翻译（1）</p><p>「雄《おす》は优《やさ》しくするとすぐ図に乗りんす。味をしめて缲《く》り返しそんな台词《せりふ》を闻かされてはたまらぬからな」</p><p>「一旦对雄性太温柔，雄性一下子就会得意忘形起来。如果让对方食髓知味，被迫反覆听同样的话语，那教人怎受得了。」</p><p>「雄は优しくてなんぼじゃ」</p><p>「雄性表现温柔值多少钱?」</p><p>「ぬしは本当にお人好《ひとよ》しじゃな。そんな颜されるとわっちのほうが困りんす」</p><p>「汝真的是个烂好人，这种表情教咱很困扰呐。」</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词 <wbr>原版加翻译（1）</p><p>「そうじゃ、帰りが二人になっておったら、ぬしは悪いが部屋から出てくりゃれ？」</p><p>「对了，汝回来时，如果发现房间里有两个人，虽然对汝很抱歉，但是汝可不可避开一下?」</p><p>「実に质の良い毛皮じゃ。わっちの尻尾には劣《おと》るがな」</p><p>「这皮草口叩质很好哏?不过，输给咱的尾巴就是了。」</p><p>「まったく。おろおろしておったほうがまだ可爱《かわい》げがあるというものじゃな」</p><p>「真实的，汝惊慌失措时的样字还比较可爱呐．」</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词 <wbr>原版加翻译（1）</p><p>「ふむ。そう考えると良き雄であることと、良き大人であることは相｜容《い》れぬことなのかもしれぬ。良き雄は子供じみておる。良き大人は腑抜《ふぬ》けておる」</p><p>「思。这么一想，或许好雄性的表现和好大人的表现互不相容。奸雄性显得孩子气，而好大人显得窝囊。」</p><p>「わっちゃあ……帰る场所が、なくなってしまいんす……」</p><p>「咱啊……无家可归了……」</p><p>「わ、わっちゃあ独《ひと》りになってしまった。どう、ど、うすればよい？　わっちの帰りを待ってくれる者はもうおらぬ。どこにもおらぬ……。わっちゃあ……独りになってしまった……」</p><p>「咱、咱变成孤单一人了。怎么……怎……么办才好?已经没有人在等着咱回去了，哪儿都没有……咱……变成孤单一人了……」P.S.动画里这块赫萝哭着说这几句话的时候杀伤力确实太大了。。</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词 <wbr>原版加翻译（1）</p><p>「汝是咱的什么人啊……不对，咱是汝的什么人啊?」</p><p>「嫌《いや》じゃ！　もう独りは嫌じゃ！」</p><p>「咱不要!咱不要再孤单一人了!」</p><p>（i ya jia！ mo u hi to li wa i ya jia）</p><p>「なあ、ぬしよ、わっちを抱《だ》いてくりゃれ？」</p><p>「咱说汝啊，抱咱好吗?」</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词 <wbr>原版加翻译（1）</p><p>「リュビンハイゲンで言ったことだろう？　下手な小细工をしないで、本心をあるがまま言えと。互《たが》いに怒鸣《どな》り合ったほうが早く问题が片づくと」</p><p>「在留宾海根时，咱不是说过了吗?不要做一些没用的小动作，直接把真心话说出来：互相怒骂会比较快解决问题。」</p><p>「下手の考え休むに似たりとはこのことじゃ！　わっちの苦心をなにもかも台无しにしおって、あまつさえわっちがぬしの敌に回っておったじゃと？　その上｜妙《みょう》に若僧《わかぞう》との契约《けいやく》に执着《しゅうちゃく》しおって、そのせいでどれほどややこしくなったかわかっておるのか！　ぬしと出会ったのは确かにほんの最近じゃ。それでもわっちゃあぬしとは浅からぬ绊《きずな》ができていたと思う。それはわっちの思い込みだったのかや？　それともぬしは本当に――」</p><p>「所谓笨人想不出好主意来，指的就是汝!咱的苦心全都被汝躇蹋了不打紧，汝还说咱把汝当成了敌人是吗?而且，汝竟然那么执着于和那小毛头的契约，汝知道这样让事情变得有多复杂吗?咱确实是最近才遇上汝没错，但是咱认为和汝之间有着不算浅的羁绊。是咱一厢情愿这么认为吗?还是汝其实——」</p><p>「ぬしがその気ならわっちはかまわぬ。その代わり……」</p><p>「既然汝有这样的打算，咱是无所谓。不过……」</p><p>「优《やさ》しくしてくりゃれ？」</p><p>「汝要温柔点，好呗?」</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词 <wbr>原版加翻译（1）</p><p>「わっちは故郷に帰りたい。たとえ……なくなっていても」</p><p>「咱想回到故乡，哪怕……它已经不存在了。」</p><p>「わっちゃあ、あの人形のように情热的なことでもかまわぬが？」</p><p>「咱呐，就算要像那玩偶的火焰般熟情也无所谓，汝呢?」</p><p>「ぬしの侧《そば》でうつらうつらする」</p><p>[那咱就还在汝身上打盹。]</p><p>[转]整理小说《狼与香辛料》中萌狼经典的台词 <wbr>原版加翻译（1）</p><p>to be continued...</p>]]></content>
    
    
    <categories>
      
      <category>狼与香辛料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>狼与香辛料</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PDH锁频技术</title>
    <link href="/2024/07/13/PDH%E9%94%81%E9%A2%91%E6%8A%80%E6%9C%AF/"/>
    <url>/2024/07/13/PDH%E9%94%81%E9%A2%91%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="pdh激光稳频技术">PDH激光稳频技术</h1><h2 id="介绍">介绍</h2><p>基于频率调制（FM）。PHD技术是提高激光频率稳定性的技术。激光频率由FP腔测得，测量结果反馈到激光器中抑制频率漂移。好处是系统不会被FP腔的响应时间限制，频率浮动比腔的响应速度快。</p><h2 id="概念模型">概念模型</h2><p>很多现代激光器是可调谐的，自带能反馈电信号的输入接口调节输出频率。如果能精确测量激光频率，并反馈回调谐接口，借助控制系统，能保持频率不变。</p><h3 id="fp腔原理">FP腔原理</h3><p>在光学中，法布里－佩罗干涉仪（英文：Fabry–Pérotinterferometer）是一种由两块平行的玻璃板组成的多光束干涉仪，其中两块玻璃板相对的内表面都具有高反射率。法布里－佩罗干涉仪也经常称作法布里－佩罗谐振腔、F-P腔或法-珀腔（英語：F-PCavity），并且当两块玻璃板间用固定长度的空心间隔物来间隔固定时，它也被称作法布里－佩罗标准具或直接简称为标准具（来自法语étalon，意为“测量规范”或“标准”），但这些术语在使用时并不严格区分。这一干涉仪的特性为，当入射光的频率满足其共振条件时，其透射频谱会出现很高的峰值，对应着很高的透射率。法布里－佩罗干涉仪这一名称来自法国物理学家夏尔·法布里和阿尔弗雷德·佩罗（摘自wiki）。</p><p>当FP腔尺寸远大于入射波长，可用多光束干涉进行描述。</p><figure><img src="/images/M1M2.jpg" title="FP图片" alt="FP图片" /><figcaption aria-hidden="true">FP图片</figcaption></figure><p>如图，入射光为<spanclass="math inline">\(E_{in}\)</span>，两镜透射系数和反射系数分别为<spanclass="math inline">\(T_1, ~ T_2\)</span>和<spanclass="math inline">\(R_1, ~ R_2\)</span>。两镜间隔为<spanclass="math inline">\(L\)</span>。</p><p>不考虑吸收有<span class="math inline">\(T_1 + R_1=1; ~ T_2 + R_2 =1\)</span>，入射光被<spanclass="math inline">\(M_1\)</span>外侧反射为<spanclass="math inline">\(E_{ in }\sqrt{R_1}\)</span>。在薄膜介质折射率<spanclass="math inline">\(n_1, n_2\)</span>相等条件下，折射率有如下关系<spanclass="math inline">\(r = -r&#39;\)</span>，相位反转180度。</p><p>反射光强</p><p><span class="math display">\[\begin{aligned}    E_{ref} &amp;= -E_{in}\sqrt{R_1} +E_{in}T_1\sqrt{R_2}e^{iw\frac{2L}{C}} + E_{in}T_1\sqrt{R_2}\sqrt{R_1R_2}e^{iw\frac{4L}{C}} + ... \\            &amp;= -E_{in}\sqrt{R_1} +E_{in}T_1\sqrt{R_2}e^{iw\frac{2L}{C}} \left( 1 + \sqrt{R_1R_2}e^{iw\frac{2L}{C}} + R_1 R_2e^{iw\frac{4L}{C}} + ... \right) \\            &amp;= -E_{in}\sqrt{R_1} +E_{in}T_1\sqrt{R_2}e^{iw\frac{2L}{C}} \cdot \frac{1}{ 1 - \sqrt{R_1R_2}e^{iw\frac{2L}{C}} }\end{aligned}\]</span></p><p>若两个镜子反射率相同，即<span class="math inline">\(R_1 = R_2 =r^2\)</span>，其中<spanclass="math inline">\(R\)</span>为光强反射率，r为振幅反射率。则原式<span class="math display">\[\begin{aligned}    &amp;= -E_{in}r + \frac{ E_{in}(1 - R_1 )r e^{iw\frac{2L}{C}} }{ 1 -r^2 e^{iw\frac{2L}{C}} }, ~~~~ \Delta\nu_{fsr} = \frac{C}{2L} \\    &amp;= -E_{in}r + \frac{ E_{in}(1 - r^2 )re^{iw\frac{1}{\Delta\nu_{fsr}}} }{ 1 - r^2e^{iw\frac{1}{\Delta\nu_{fsr}}} }\end{aligned}\]</span></p><p>故电场反射耦合系数 <span class="math display">\[\begin{aligned}F(w) &amp;= \frac{ E_{ref} }{ E_{in} } = -r + \frac{ (1-r^2)r e^{iw\frac{1}{\Delta\nu_{fsr}}} }{ 1 - r^2e^{iw\frac{1}{\Delta\nu_{fsr}} }}\\     &amp;= \frac{ E_{ref} }{ E_{in} } = \frac{ r (e^{iw\frac{1}{\Delta\nu_{fsr}}} - 1) }{ 1 - r^2e^{iw\frac{1}{\Delta\nu_{fsr}}}}\end{aligned}\]</span> 线宽 <span class="math display">\[\Delta\nu_c = \frac{\Delta\nu_{fsr}}{F}\]</span></p><p>精细度 <span class="math display">\[F=\frac{\pi r}{1-r^2}\]</span></p><figure><img src="/images/PDH原理图.jpg" title="PDH原理图" alt="PDH原理图" /><figcaption aria-hidden="true">PDH原理图</figcaption></figure><p>PDH技术之前的激光锁定有些缺陷：无法区分激光频率的波动和激光器本身光强波动。</p><p>反射光强关于共振点对称，若不共振，无法区分频率是高于还是低于共振频率（通过观察反射光强的谱线）。注意到共振点两侧斜率（导数）有正负之分，可以用来区分，这个误差信号可以用来锁定激光。</p><blockquote><p>Pocket cell 泡克尔斯盒 用于电光相位调制<spanclass="math inline">\(E_{入} = A\cos wt,~~~~ E_{出} = A\cos (wt + \beta\sin w_mt)\)</span>，<spanclass="math inline">\(\beta\)</span>为调制深度。</p></blockquote><p>光隔离器由偏振分束PBS和<spanclass="math inline">\(\lambda/4\)</span>波片组成。</p><p>反射光经过光隔离器打入光探测器，其输出与本地振荡器的信号通过混频器作比较，其输出包含直流（或低频）和两倍调制频率信号，我们要用低频成分计算误差并送入伺服系统控制反馈。</p><p>如果缓慢抖动激光频率，此概念模型可以生效。如果抖动太快，腔内共振光不能及时完全上升或下降，输出将不会按照FIG4显示。此PDH技术在高频调制下仍能工作，噪声和伺服系统的带宽都提高了，在解决在用于高频区的概念模型之前，可建立量化模型。</p><figure><img src="/images/PDH_FIG4.jpg" title="PDH_FIG4" alt="PDH_FIG4" /><figcaption aria-hidden="true">PDH_FIG4</figcaption></figure><h2 id="量化模型">量化模型</h2><h3 id="a-fp腔单色光的反射">A FP腔单色光的反射</h3><p>FP腔反射光实际由两方面组成</p><ol type="1"><li>快速反射光（被M反射后再没进入腔）</li><li>漏光（驻波在腔内往返过程中漏出的透射光）</li></ol><p>这两种光有相同的频率，近共振（在无损对称腔中）其强度也几乎相同，但其相位严重依赖激光频率。</p><blockquote><p>case 1 若完美共振，则<span class="math inline">\(\nu = N\cdot \Delta\nu_{fsr}\)</span></p><p>反射光中类型1和2有相同的振幅和相反相位，两光干涉相消，若反射光消失，即<spanclass="math inline">\(F(w)=0\)</span></p></blockquote><blockquote><p>case 2 若不完美共振，则<span class="math inline">\(\nu \neq N\cdot\Delta \nu_{fsr}\)</span></p><p>不完美指有小偏差。<span class="math inline">\(\nu\)</span>与<spanclass="math inline">\(N\cdot \Delta\nu_{fsr}\)</span>足够接近，能建立驻波。反射光中类型1和2的相位差不是180度，不会完全相消。部分光反射出腔，其相位彰显激光频率位于共振点左侧/右侧，如图FIG5所示。</p></blockquote><figure><img src="/images/PDH_FIG5.jpg" title="PDH_FIG5" alt="PDH_FIG5" /><figcaption aria-hidden="true">PDH_FIG5</figcaption></figure><p>FIG6中，随着激光频率<span class="math inline">\(w\)</span>增加，<spanclass="math inline">\(F(w)\)</span>沿着园作逆时针运动（当<spanclass="math inline">\(w\)</span>均匀增加的时候，函数在B点附近对<spanclass="math inline">\(w\)</span>变化敏感，在A点附近对<spanclass="math inline">\(w\)</span>变化不敏感）。 通过matlab模拟<spanclass="math inline">\(F(w)\)</span>的复数值，大多数情况下靠近-1（A点）</p><figure><img src="/images/PDH_matlab模拟.png" title="PDH_matlab模拟"alt="PDH_matlab模拟" /><figcaption aria-hidden="true">PDH_matlab模拟</figcaption></figure><figure><img src="/images/PDH_FIG6.jpg" title="PDH_FIG6" alt="PDH_FIG6" /><figcaption aria-hidden="true">PDH_FIG6</figcaption></figure><p>可见在近共振时，灵敏度较大</p><h3 id="b-测量反射光相位">B 测量反射光相位</h3><p>若抖动激光频率，将提供足够信息表明处于共振哪一侧，更量化的思考方式是，调制激光器的频率（或相位）将产生与入射光和反射光具有确定相位关系的边带，这些边带与入射光和反射光频率不同，但仍存在确定相位关系，若用反射光束干涉这些边带，则总和会显示调制频率下的拍频，拍频相位将告知反射光束的相位，边带设定了一个相位标准。通过该标准可以测量反射光束的相位。</p><h3 id="c-调制激光边带">C 调制激光：边带</h3><p>量化模型中调制频率，实际中调制相位更容易，结果相同，但描述相位的数字方式更简单。通过pocketscell电光调制相位后，其入射电场变为</p><p><span class="math display">\[E_{inc} = E_0 e^{i(wt + \beta \sin \Omega t)}~~~~ \Omega 是调制频率,~~~~ \beta 是调制深度\]</span></p><p>用贝塞尔函数展开</p><p><span class="math display">\[\begin{aligned}    E_{inc} &amp;\approx [J_0(\beta) + 2\sigma J_1(\beta)\sin \Omegat]e^{iwt} \cdot E_0 \\    &amp;= E_0 [J_0(\beta)e^{iwt} + J_1(\beta)e^{i(w+\Omega)t} -J_1(\beta)e^{i(w-\Omega)t}]\end{aligned}\]</span></p><p>若<span class="math inline">\(P_0 =|E_0|^2\)</span>是入射光总功率，忽略干涉效应<spanclass="math inline">\(P_c = J_0^2(\beta)P_0\)</span></p><p>一阶边带功率<span class="math inline">\(P_s =J_1^2(\beta)P_0\)</span>。当<span class="math inline">\(\beta &lt;1\)</span>时，<span class="math inline">\(P_c + 2P_s \approxP_0\)</span></p><h3 id="d-调制信号的反射误差信号">D 调制信号的反射：误差信号</h3><p><span class="math display">\[\begin{aligned}    E_{ref} &amp;= E_{in}\cdot F(w) \\            &amp;= E_0[F(w)J_0(\beta)e^{iwt} + F(w +\Omega)J_1(\beta)e^{i(w+\Omega)t} -F(w-\Omega)J_1(\beta)e^{i(w-\Omega)t}]\end{aligned}\]</span></p><p>由于光电二极管作为误差信号探测器，实际上测量的是光强<spanclass="math inline">\(P_{ref} =|E_{ref}^2|\)</span>，故光电二极管起到一个混频器的作用，每项与另外两项混频得到</p><p><span class="math display">\[P_{ref} = |E_{ref}|^2 = E_{ref} \cdot E_{ref}^*\]</span></p><blockquote><p><span class="math inline">\(P_c = E_0^2J_0^2(\beta)~~~~P_s =E_0^2J_1^2(\beta)\)</span></p></blockquote><p><span class="math display">\[E_{ref} = E_0[F(w)J_0(\beta)e^{iwt} + F(w +\Omega)J_1(\beta)e^{i(w+\Omega)t} -F(w-\Omega)J_1(\beta)e^{i(w-\Omega)t}]\]</span> <span class="math display">\[E_{ref}^* = E_0[F^*(w)J_0(\beta)e^{iwt} + F^*(w +\Omega)J_1(\beta)e^{i(w+\Omega)t} -F^*(w-\Omega)J_1(\beta)e^{i(w-\Omega)t}]\]</span></p><p>所以</p><p><span class="math display">\[\begin{aligned}    P_{ref} &amp;= |E_{ref}|^2 = E_{ref} \cdot E_{ref}^* \\            &amp;= E_0^2 |F(w)|^2J_0^2(\beta) + E_0^2F(w+\Omega)F^*(w+\Omega)J_1^2(\beta) \\            &amp;~~~~+ E_0^2 F(w-\Omega)F^*(w-\Omega)J_1^2(\beta) +E_0^2 F(w)F^*(w+\Omega)J_0(\beta)J_1(\beta)e^{-i\Omega t} \\            &amp;~~~~- E_0^2F(w)F^*(w-\Omega)J_0(\beta)J_1(\beta)e^{i\Omega t} + E_0^2F^*(w)F(w+\Omega)J_0(\beta)J_1(\beta)e^{i\Omega t} \\            &amp;~~~~- E_0^2F(w+\Omega)F^*(w-\Omega)J_1^2(\beta)e^{2i\Omega t} - E_0^2F^*(w)F(w-\Omega)J_0(\beta)J_1(\beta)e^{-i\Omega t} \\            &amp;~~~~- E_0^2 F(w-\Omega)F^*(w+\Omega)J_1^2(\beta)e^{-2i\Omega t} \\            &amp;= P_c|F(w)|^2 + P_s \{ |F(w + \Omega)|^2 +|F(w-\Omega)|^2 \} \\            &amp;~~~~ +[F(w)F^*(w+\Omega) -F^*(w)F(w-\Omega)]E_0^2J_0(\beta)J_1(\beta)e^{-i\Omega t} \\            &amp;~~~~ +[F^*(w)F(w+\Omega) -F(w)F^*(w-\Omega)]E_0^2J_0(\beta)J_1(\beta)e^{i\Omega t} + ~~其余2\Omega项\end{aligned}\]</span></p><p>设<span class="math inline">\(F(w)F^*(w+\Omega)=a+bi\)</span></p><p>则<span class="math inline">\(F^*(w)F(w+\Omega)=a-bi\)</span></p><p>原式变为 <span class="math display">\[P_{ref} = P_c|F(w)|^2 + P_s \{ |F(w + \Omega)|^2 + |F(w-\Omega)|^2 \} +E_0^2J_0(\beta)J_1(\beta)[ (a+bi)e^{-i\Omega t} + (a-bi)e^{i\Omega t} ]\]</span></p><p>而 <span class="math display">\[\begin{aligned}    &amp;(a+bi)e^{-i\Omega t} + (a-bi)e^{i\Omega t} \\    &amp;= (a+bi)(\cos \Omega t - i \sin \Omega t) + (a-bi)(\cos\Omega t+ i\sin\Omega t) \\    &amp;= 2a\cos \Omega t + 2b\sin \Omega t\end{aligned}\]</span></p><p>所以 <span class="math display">\[P_{ref} = P_c|F(w)|^2 + P_s \{ |F(w + \Omega)|^2 + |F(w-\Omega)|^2 \} +2\sqrt{P_c P_s}( a\cos \Omega t + b\sin \Omega t )\]</span></p><p>我们只对<span class="math inline">\(\cos \Omega t\)</span>或<spanclass="math inline">\(\sin \Omega t\)</span>感兴趣，因为其反映了相移</p><ul><li>若调制频率很小（<span class="math inline">\(\Omega \ll \Delta\nu_c\)</span>），则<span class="math inline">\(F(w)F^*(w+\Omega) -F^*(w)F(w-\Omega)\)</span>为实数，正弦项为0，留住余弦项。</li><li>若调制频率很大（<span class="math inline">\(\Omega \gg \Delta\nu_c\)</span>），则<span class="math inline">\(F(w\pm \Omega) \approx-1,~~~~ F(w)F^*(w+\Omega)-F*(w)F(w-\Omega)\)</span>为虚数，余弦项为0，留正弦项。</li></ul><blockquote><p>证明：</p><p>当<spanclass="math inline">\(\Omega\)</span>很小，用泰勒公式展开，保留前两项</p><p><span class="math inline">\(F(w)F^*(w+\Omega) -F^*(w)F(w-\Omega)\)</span></p><p><span class="math inline">\(=F(w)(F^*(w) + \frac{dF^*(w)}{dw} \cdot\Omega) - F^*(w)(F(w) - \frac{dF(w)}{dw} \cdot \Omega)\)</span></p><p><span class="math inline">\(=[F(w)\frac{dF^*(w)}{dw} +F^*(w)\frac{dF(w)}{dw}] \Omega\)</span></p><p><span class="math inline">\(= \frac{d[F(w)F^*(w)]}{dw} \Omega=\frac{d|F|^2}{dw}\Omega\)</span></p><p>结果为实数</p><p>通过matlab计算，当<span class="math inline">\(\Omega \gg \Delta\nu_c\)</span>时，确实有<span class="math inline">\(F(w\pm \Omega)\approx -1\)</span>，众多值集中在复平面（FIG6）的A点，故</p><p><span class="math inline">\(F(w)F^*(w+\Omega) - F^*(w)F(w-\Omega) =-2bi = -i \cdot 2Im[F(w)]\)</span></p><p>结果为虚数</p></blockquote><p>取正弦或余弦的一次分量，可通过使用混频器与滤波器来实现。</p><p>如果输入信号都是sin，那么<span class="math inline">\(\sin(\Omegat)\sin(\Omega&#39; t) = 1/2 \{ \cos[(\Omega - \Omega&#39;)t] -\cos[(\Omega + \Omega&#39;)t] \}\)</span>。若<spanclass="math inline">\(\Omega = \Omega&#39;\)</span>，则<spanclass="math inline">\(\cos(\Omega -\Omega&#39;)t\)</span>为直流分量，正是我们需要的，可以用一个低通滤波器滤除<spanclass="math inline">\(\cos(\Omega + \Omega&#39;)t\)</span>而保留<spanclass="math inline">\(\cos(\Omega - \Omega&#39;)t\)</span></p><p>如果输入信号是sin和cos，那么<span class="math inline">\(\sin(\Omegat)\cos(\Omega&#39; t) = 1/2 [\sin(\Omega - \Omega&#39; t) - \sin(\Omega+ \Omega&#39;)t]\)</span> 当<span class="math inline">\(\Omega =\Omega&#39;\)</span>，<span class="math inline">\(\sin(\Omega -\Omega&#39;)t=0\)</span>无意义。故需要注意混频器两端输入信号相位，使混频器项均为正弦项。实际上，由于不同系统输入到混频器两端的信号相位不同，往往在混频器前加一个可调移相器，以便混频时能使两信号相位适配。</p><h2 id="理解量化模型">理解量化模型</h2><h3 id="a-慢调制概念模型的量化">A 慢调制概念模型的量化</h3><p>当驻波锁定时，<spanclass="math inline">\(w\)</span>是一个定值，在未锁定时，<spanclass="math inline">\(w\)</span>会有一个变化的漂移范围，是一个变量。用<spanclass="math inline">\(w(t)\)</span>表示。即<spanclass="math inline">\(w(t)\)</span>缓慢抖动</p><p><span class="math display">\[E_{in} = E_0 \cos(wt + \beta \sin \Omega t)\]</span></p><p>相位是<span class="math inline">\(wt + \beta \sin \Omegat\)</span>，则瞬时频率<span class="math inline">\(w(t) =\frac{d\phi}{dt} = \frac{d(wt + \beta \sin \Omega t)}{dt} =w+\Omega\beta\cos\Omega t\)</span></p><p>慢调制下<span class="math inline">\(\Omega \approx 0\)</span></p><p><span class="math display">\[P_{ref} = P_0|F(w)|^2\]</span></p><p><span class="math display">\[\begin{aligned}    P_{ref}(w + \Omega\beta\cos\Omega t) &amp;\approx P_ref(w) +\frac{dP_ref}{dw} \cdot \Omega\beta \cos \Omega t \\    &amp;\approx P_ref(w) + P_0\frac{d|F(w)|^2}{dw} \cdot\Omega\beta\cos\Omega t\end{aligned}\]</span></p><p>概念模型中，在隔热环境下缓慢抖动激光频率w，使腔内驻波总是与入射光束相均衡，在量化模型中可用很小的<spanclass="math inline">\(\Omega\)</span>表达</p><p>前面证明了<span class="math inline">\(F(w)F^*(w+\Omega) -F^*(w)F(w-\Omega) = \frac{d|F(w)|^2}{dw}\cdot\Omega\)</span>是实数，只有余弦项。若我们使<spanclass="math inline">\(\sqrt{P_c P_s}\)</span>约等于<spanclass="math inline">\(P_0\beta / 2\)</span></p><p>那么<span class="math inline">\(P_{ref} = 常数项 +P_0\frac{d|F(w)|^2}{dw} \cdot \Omega\beta\cos\Omega t + (2\Omega项)\)</span></p><p>量化模型与概念模型抑制，混频器会消除除<spanclass="math inline">\(\cos\Omega t\)</span>之外的其余项</p><p>PDH误差信号<span class="math inline">\(\varepsilon =P_0\frac{d|F(w)|^2}{dw}\Omega\beta \approx 2\sqrt{P_cP_s}\frac{d|F(w)|^2}{dw}\Omega\)</span> 其中<spanclass="math inline">\(|F(w)|^2\)</span>表征输出光强，<spanclass="math inline">\(\frac{d|F(w)|^2}{dw}\)</span>可表示光强I随<spanclass="math inline">\(w\)</span>变化的导数，在共振两侧，导数有正负之分，在误差图中<spanclass="math inline">\(\varepsilon\)</span>有正负之分。</p><h3 id="b-近共振快调制实操中的pdh">B 近共振快调制，实操中的PDH</h3><p>当<span class="math inline">\(w\)</span>近共振，即<spanclass="math inline">\(w\approx 2\pi N\Delta\nu_{fsr}\)</span>，调制频率<spanclass="math inline">\(\Omega\)</span>很高，边带消失。假设边带被完全反射，<spanclass="math inline">\(F(w\pm \Omega) \approx-1\)</span>，由于近共振，则<span class="math inline">\(F(w)\approx0\)</span> <span class="math inline">\(F(w)F^*(w+\Omega) -F^*(w)F(w-\Omega) \approx -i\cdot 2 Im{F(w)}\)</span>，证明见前文。</p><p>所以<span class="math inline">\(P_{ref} \approx 2P_s - 4\sqrt{P_cP_s} Im{F(w)}\sin\Omega t + 2\omega 项\)</span></p><p><span class="math inline">\(\varepsilon \approx -4\sqrt{P_cP_s}Im{F(w)}\)</span></p><p>由于近共振 <span class="math display">\[\frac{w}{\Delta \nu_{fsr}} = 2\pi N + \frac{\delta w}{\Delta \nu_{fsr}}~~~~ \delta w是w偏离共振频率的偏量，N是整数\]</span></p><p>若腔的精细度很高<span class="math inline">\(F\approx\frac{\pi}{1-r^2}~~~~r\approx 1\)</span> <span class="math display">\[\frac{\delta w}{\Delta \nu_{fsr}} = \frac{\delta w}{\Delta \nu_c\mathcal{F}}\]</span></p><p><span class="math display">\[F(w) = \frac{ r(e^{i\frac{\delta w (1-r^2)}{\Delta \nu_c \pi }} \cdote^{i2\pi N} - 1) }{1 - r^2 e^{i\frac{\delta w (1-r^2)}{\Delta \nu_c \pi}}\cdot e^{i2\pi N} }\]</span></p><p>由于 <span class="math display">\[e^{i2\pi N} = 1 , ~~~~ r \approx 1, ~~~~ \delta w很小\]</span></p><p>所以 <span class="math display">\[F(w) = \frac{ i\delta w }{ \Delta \nu_c \pi }\]</span></p><p>带入误差信号公式 <span class="math display">\[\varepsilon \approx - \frac{ 4 }{ \pi } \sqrt{ P_c P_s } \cdot \frac{\delta w }{ \delta \nu_c } ~~~~ \delta \nu_c = \frac{ \Delta \nu_{fsr}}{ \mathcal{F} }线宽\]</span></p><p>误差信号<span class="math inline">\(\varepsilon\)</span>正比于<spanclass="math inline">\(\delta w\)</span>，只要<spanclass="math inline">\(\delta w \ll \delta\nu_c\)</span>，上式就会成立。误差信号是线性近共振的，能用线性控制理论来抑制频率噪声。</p><p>用<span class="math inline">\(f = \nu = \frac{ w }{ 2\pi}\)</span>来代替更符合习惯</p><p><span class="math display">\[\varepsilon = -8\sqrt{ P_c P_s } \cdot \frac{ \delta f }{ \delta \nu_c }~~~~ \varepsilon = D \cdot \delta f ~~~~ D = -\frac{ 8\sqrt{ P_c P_s }}{ \delta \nu_c }\]</span></p><p>思考与理解</p><p>（A）慢调制中，<span class="math inline">\(w(t) = w + \Omega\beta\cos \Omega t\)</span>表征了频率抖动与调制频率<spanclass="math inline">\(\Omega\)</span>的关系。即中心频率为<spanclass="math inline">\(w\)</span>，以<spanclass="math inline">\(\Omega\beta\)</span>为振幅的余弦波动</p><figure><img src="/images/PDH_FIG7.jpg" title="PDH_FIG7" alt="PDH_FIG7" /><figcaption aria-hidden="true">PDH_FIG7</figcaption></figure><p>对应在光强随<spanclass="math inline">\(w\)</span>变化图中，有在在曲线上对应A-&gt;B-&gt;A-&gt;C-&gt;A的振动</p><p>功率<span class="math inline">\(P_{ref}(w + \Omega\beta\cos \Omega t)\approx P_{ref}(w) + P_0\frac{d|F|^2}{dw} \Omega \beta \cos \Omegat\)</span>其中<span class="math inline">\(w\)</span>为中心频率，即<spanclass="math inline">\(w_A\)</span></p><p>从A到B过程中：<span class="math inline">\(\cos\Omega t &gt; 0 ~~~~\frac{ d|F|^2 }{ dw } &lt; 0 ~~~~~ P_B &lt; P_A\)</span></p><p>从A到C过程中：<span class="math inline">\(\cos\Omega t &lt; 0 ~~~~\frac{ d|F|^2 }{ dw } &lt; 0 ~~~~~ P_C &gt; P_A\)</span></p><p>上述为<span class="math inline">\(w \neq 2\pi N \Delta\nu_{fsr}\)</span>的情形 若<span class="math inline">\(w = 2\pi N \Delta\nu_{fsr}\)</span>，即近共振时</p><p>从A到B过程中：<span class="math inline">\(\cos\Omega t &gt; 0 ~~~~\frac{ d|F|^2 }{ dw } &lt; 0 ~~~~~ P_B &lt; P_A\)</span></p><p>从A到C过程中：<span class="math inline">\(\cos\Omega t &lt; 0 ~~~~\frac{ d|F|^2 }{ dw } &gt; 0 ~~~~~ P_C &lt; P_A\)</span></p><figure><img src="/images/PDH_FIG8.jpg" title="PDH_FIG8" alt="PDH_FIG8" /><figcaption aria-hidden="true">PDH_FIG8</figcaption></figure><p>其误差信号 <span class="math display">\[\varepsilon = P_0 \frac{ d|F|^2 }{ dw } \Omega \beta \approx 2\sqrt{ P_cP_s } \frac{ d|F|^2 }{ dw } \Omega\]</span></p><p>注意在把误差信号送入混频器前必须调整其相位（-90度）</p><figure><img src="/images/PDH_FIG9.jpg" title="PDH_FIG9" alt="PDH_FIG9" /><figcaption aria-hidden="true">PDH_FIG9</figcaption></figure><p>慢调制中没有规定“近共振”这一条件，换言之，<spanclass="math inline">\(w(t)\)</span>的中心频率<spanclass="math inline">\(w\)</span>不是<span class="math inline">\(\Delta\nu_{fsr}\)</span>的整数倍。不近共振同样可以采取上述分析方法，上述方法中的近似是在<spanclass="math inline">\(\Omega \approx 0\)</span>时进行，与共振无关。</p><p>（B）块调制中，有个前提就是“近共振”。在这一条件下，有诸多近似关系：<span class="math display">\[F(w) \approx 0 ~~~~ w \approx 2\pi N \Delta \nu_{fsr}\]</span></p><figure><img src="/images/PDH_FIGA.jpg" title="PDH_FIGA" alt="PDH_FIGA" /><figcaption aria-hidden="true">PDH_FIGA</figcaption></figure><p>由于<span class="math inline">\(F(w)\)</span>是逆时针旋转的直向量功率最低点处，<span class="math inline">\(w = \pi N \Delta\nu_{fsr}\)</span>，有<span class="math inline">\(F(w) =-1\)</span>，其中<span class="math inline">\(N\)</span>为奇数。</p><p>事实上，不只有最低点处才有<span class="math inline">\(F(w)\approx-1\)</span>，由matlab可知<spanclass="math inline">\(F(w)\)</span>在绝大多数情况下均可以近似为-1。而<spanclass="math inline">\(F(w)=-1\)</span>的物理意义是该频率的光没有在腔内形成共振，被完全反射出腔外。</p><p>非近共振光的确只要不满足<span class="math inline">\(\nu = \frac{ C }{2L }q\)</span>就无法在腔内共振，只有在近共振情形下，复平面的圆才会有较为可观虚部的<spanclass="math inline">\(F(w)\)</span></p><figure><img src="/images/PDH_FIGB.jpg" title="PDH_FIGB" alt="PDH_FIGB" /><figcaption aria-hidden="true">PDH_FIGB</figcaption></figure><p>由误差信号公式<span class="math inline">\(\varepsilon = D\deltaf\)</span>不难看出<spanclass="math inline">\(\varepsilon\)</span>是与<spanclass="math inline">\(\deltaf\)</span>成比例的正比例函数。由于该式是在<spanclass="math inline">\((\delta w \ll \delta\nu_c)\)</span>的前提下推导出来的，在图中只表现为共振处附近的斜线，其余部分是非线性的，与<spanclass="math inline">\(\varepsilon = D\deltaf\)</span>无关。我们只关注线性部分的变化</p><figure><img src="/images/PDH_FIGC.jpg" title="PDH_FIGC" alt="PDH_FIGC" /><figcaption aria-hidden="true">PDH_FIGC</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>激光稳频</category>
      
    </categories>
    
    
    <tags>
      
      <tag>光学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>量子力学的符号与算符</title>
    <link href="/2024/07/13/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E7%AC%A6%E5%8F%B7%E4%B8%8E%E7%AE%97%E7%AC%A6/"/>
    <url>/2024/07/13/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E7%AC%A6%E5%8F%B7%E4%B8%8E%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="量子力学的符号与算符">量子力学的符号与算符</h1><h2 id="前言">前言</h2><p>博主研0，刚开始接触里德堡原子微波测量。知网上的硕士毕业论文里有很多量子光学相关的公式推导。这些原理性的东西其实实验中一般不会去仔细推敲，都是在已有基础上玩点新花样。但是即便如此，博主还是想至少看得懂公式中各种符号的含义，减少以后写论文时产生的原则性错误。非常推荐看birdsong-mayflower.github.io的量子力学笔记，对初学者很友好。博主在这只是抄一些定义。</p><h2 id="狄拉克符号">狄拉克符号</h2><p><spanclass="math inline">\(\ket{\psi}\)</span>为使用狄拉克符号表示的波函数<spanclass="math inline">\(\psi\)</span>，这个形式称作右矢(ket)。</p><p>以一维无限深方势阱中的能量本征态为例。</p><p>设：</p><p><span class="math display">\[\ket{\psi_1} = \begin{pmatrix}    1 \\    0 \\    0 \\    . \\    . \\    . \\    0 \\    . \\    . \\    .\end{pmatrix},\ket{\psi_2} = \begin{pmatrix}    0 \\    1 \\    0 \\    . \\    . \\    . \\    0 \\    . \\    . \\    .\end{pmatrix},\ket{\psi_n} = \begin{pmatrix}    0 \\    0 \\    0 \\    . \\    . \\    . \\    n \\    . \\    . \\    .\end{pmatrix}\]</span></p><p><span class="math display">\[\ket{\psi_n} = \psi_n(x) = \sqrt{ \frac{2}{a} } \sin \frac{n\pi}{a} x\]</span></p><p>那么对于任意的量子态<span class="math inline">\(\lambda = \sum_n c_n\psi_n\)</span>，可以写作： <span class="math display">\[\ket{\lambda} = \begin{pmatrix}    c_1 \\    c_2 \\    c_3 \\    . \\    . \\    .\end{pmatrix}\]</span></p><p>与右矢对应的是左矢(bra)，右矢是列向量，左矢是行向量</p><p>如果 <span class="math display">\[\ket{\psi} = \begin{pmatrix}    2 \\    1\end{pmatrix}\]</span></p><p>那么 <span class="math display">\[\bra{\psi} = (2, 1)\]</span></p><h2 id="厄米共轭">厄米共轭</h2><p>一个矩阵的厄米共轭定义：对矩阵取转置，然后对矩阵中所有元素取复共轭。</p><p>厄米共轭记号(latex中用 \dagger，短剑的意思)：</p><p><span class="math display">\[\hat{A}^{\dagger}\]</span></p><p>对于波函数： <span class="math display">\[\ket{\psi}^{\dagger} = \bra{\psi}\]</span></p><h2 id="厄米算符">厄米算符</h2><p>算符的矩阵形式取其厄米共轭后保持不变的算符，称为厄米算符。</p><p><span class="math display">\[\hat{A}^{\dagger} = \hat{A}\]</span></p><h2 id="算符对易关系">算符对易关系</h2><p>算符的作用顺序不同结果未必相同。</p><p>算符作用顺序：式<spanclass="math inline">\(\hat{A}\hat{B}\hat{C}\ket{\psi}\)</span>中，先<spanclass="math inline">\(\hat{C}\)</span>，再<spanclass="math inline">\(\hat{B}\)</span>，最后<spanclass="math inline">\(\hat{A}\)</span>。</p><p>对易符号 <span class="math display">\[\left[   \hat{A} , \hat{B}  \right] = \hat{A}\hat{B} - \hat{B}\hat{A}\]</span></p><p>当 <span class="math display">\[\left[   \hat{A} , \hat{B}  \right] = 0\]</span> <span class="math inline">\(\hat{A}\)</span>和<spanclass="math inline">\(\hat{B}\)</span>是对易算符。</p><h1 id="未完待续">未完待续</h1><p>以上内容远远不够，以后慢慢更新吧</p>]]></content>
    
    
    <categories>
      
      <category>量子力学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>量子力学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>matlab_learning_2</title>
    <link href="/2024/07/08/matlab-learning-2/"/>
    <url>/2024/07/08/matlab-learning-2/</url>
    
    <content type="html"><![CDATA[<h1 id="z变换基于matlab">z变换，基于matlab</h1><h2 id="z变换由来">z变换由来</h2><p>对连续信号<span class="math inline">\(x(t)\)</span>进行采样<spanclass="math inline">\(x_s(t) = \sum_{n=-\infty}^{+\infty}x(nT)\delta(t-nT)\)</span>，对采样信号做拉普拉斯变换 <spanclass="math display">\[X(s) = \mathcal{L} \left[\sum_{n=-\infty}^{+\infty} x(nT)\delta(t-nT)\right] = \sum_{n=-\infty}^{+\infty} x(nT)\mathcal{L} [\delta(t-nT)] =\sum_{n=-\infty}^{+\infty} x(nT) e^{-nTs}\]</span></p><p>令<span class="math inline">\(z = e^{Ts}\)</span>带入上式，得到<spanclass="math inline">\(X(s) = \sum_{n=-\infty}^{+\infty} x(nT)z^{-n}\)</span></p><h2 id="z变换定义">z变换定义</h2><p><span class="math inline">\(x[n]\)</span>为离散信号 <spanclass="math display">\[X(z) = \mathcal{Z}[x[n]] = \sum_{n=-\infty}^{+\infty} x[n]z^{-n}\]</span></p><h2 id="z反变换定义">z反变换定义</h2><p><span class="math display">\[x[n] = \mathcal{Z}^{-1}[X(z)] = \frac{1}{2\pi j} \oint_c X(z)z^{n-1}dz\]</span></p><h2 id="收敛的充要条件">收敛的充要条件</h2><p><span class="math display">\[\sum_{n=-\infty}^{+\infty} | x[n]z^{-n} | = M &lt; +\infty\]</span></p><h2id="由充要条件推得不同情况下z变换的收敛域">由充要条件推得不同情况下z变换的收敛域</h2><ol type="1"><li><p>有限长序列</p><p><span class="math inline">\(x[n]\)</span> 只在 <spanclass="math inline">\(n_1 \leq n \leq n_2\)</span>有值，则z变换是有限项之和。<spanclass="math inline">\(x[n]\)</span>有界，只要<spanclass="math inline">\(0 &lt; |z| &lt; \infty\)</span>，<spanclass="math inline">\(X(z)\)</span>收敛。 有限长序列的收敛域<spanclass="math inline">\(0 &lt; |z| &lt; \infty\)</span>被称为有限<spanclass="math inline">\(z\)</span>平面。 <span class="math display">\[X(z) = \sum_{n=n_1}^{n_2} x[n]z^{-n}\]</span></p><p>不管什么样的序列，若在<spanclass="math inline">\(n&gt;0\)</span>处序列有值，则在<spanclass="math inline">\(z=0\)</span>处不收敛。若在<spanclass="math inline">\(n&lt;0\)</span>处序列有值，则在<spanclass="math inline">\(z=\infty\)</span>处不收敛。</p></li><li><p>右边序列</p><p><span class="math inline">\(x[n]\)</span>在<spanclass="math inline">\(n \geq n_1\)</span>时有值，其它为0。其z变换为<span class="math display">\[X(z) = \sum_{n=n_1}^{-1} x[n]z^{-n} + \sum_{n=0}^{\infty} x[n]z^{-n}\]</span> 等式右边第一项收敛域为<span class="math inline">\(0 \leq |z|&lt; \infty\)</span>，等式右边第二项收敛域为<spanclass="math inline">\(R_{x-} &lt; |z| \leq\infty\)</span>。收敛域合一起是<span class="math inline">\(R_{x-} &lt;|z| &lt; \infty\)</span></p></li><li><p>因果序列</p><p><span class="math inline">\(x[n]\)</span>在<spanclass="math inline">\(n \geq 0\)</span>时有值，其它为0。其z变换为 <spanclass="math display">\[X(z) = \sum_{n=0}^{\infty} x[n]z^{-n}\]</span> 收敛域为<span class="math inline">\(R_{x-} &lt; |z| \leq\infty\)</span></p></li><li><p>左边序列</p><p><span class="math inline">\(x[n]\)</span>在<spanclass="math inline">\(n \leq n_2\)</span>时有值，其它为0。其z变换为<span class="math display">\[X(z) = \sum_{n=-\infty}^{0} x[n]z^{-n} + \sum_{n=1}^{n_2} x[n]z^{-n}\]</span> 等式右边第二项收敛域为<span class="math inline">\(0 &lt; |z|\leq \infty\)</span>，等式右边第一项收敛域为<spanclass="math inline">\(0 &lt; |z| &lt;R_{x+}\)</span>。收敛域合一起是<span class="math inline">\(0 &lt; |z|&lt; R_{x+}\)</span></p></li><li><p>反因果序列</p><p><span class="math inline">\(x[n]\)</span>在<spanclass="math inline">\(n &lt; 0\)</span>时有值，其它为0。其z变换为 <spanclass="math display">\[X(z) = \sum_{n=-\infty}^{-1} x[n]z^{-n}\]</span> 收敛域为<span class="math inline">\(0 \leq |z| &lt;R_{x+}\)</span></p></li><li><p>双边序列 <spanclass="math inline">\(x[n]\)</span>在任意位置都有值。其z变换为 <spanclass="math display">\[X(z) = \sum_{n=-\infty}^{+\infty} x[n]z^{-n}\]</span> 收敛域为<span class="math inline">\(R_{x-} &lt; |z| &lt;R_{x+}\)</span></p></li></ol><h2 id="z变换性质">z变换性质</h2><table><thead><tr class="header"><th>性质</th><th>信号</th><th>z变换</th><th>收敛域</th></tr></thead><tbody><tr class="odd"><td></td><td><span class="math inline">\(x[n]\)</span></td><td><span class="math inline">\(X(z)\)</span></td><td><span class="math inline">\(R\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(x_1[n]\)</span></td><td><span class="math inline">\(X_2(z)\)</span></td><td><span class="math inline">\(R_1\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(x_2[n]\)</span></td><td><span class="math inline">\(X_3(z)\)</span></td><td><span class="math inline">\(R_2\)</span></td></tr><tr class="even"><td>线性</td><td><span class="math inline">\(ax_1[n] + bx_2[n]\)</span></td><td><span class="math inline">\(aX_1(z) + bX_2(z)\)</span></td><td>至少是<span class="math inline">\(R_1，R_2\)</span>相交</td></tr><tr class="odd"><td>时移</td><td><span class="math inline">\(x[n-n_0]\)</span></td><td><span class="math inline">\(z^{-n_0}X(z)\)</span></td><td><span class="math inline">\(R\)</span>可能增加或去除0和<spanclass="math inline">\(\infty\)</span>点</td></tr><tr class="even"><td>z域尺度变换</td><td><span class="math inline">\(e^{jw_0 n}x[n]\)</span></td><td><span class="math inline">\(X(e^{-jw_0}z)\)</span></td><td><span class="math inline">\(R\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(z_0^n x[n]\)</span></td><td><span class="math inline">\(X(z z_0^{-1})\)</span></td><td><span class="math inline">\(z_0 R\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(a^n x[n]\)</span></td><td><span class="math inline">\(X(a^{-1}z)\)</span></td><td><span class="math inline">\(R\)</span>的比例伸缩</td></tr><tr class="odd"><td>时间反转</td><td><span class="math inline">\(x[-n]\)</span></td><td><span class="math inline">\(X(z^{-1})\)</span></td><td><span class="math inline">\(R^{-1}\)</span></td></tr><tr class="even"><td>时间扩展</td><td><span class="math inline">\(x_{(k)}[n] = x[r], n = rk; ~~ x_{(k)}[n]= 0, n \neq rk\)</span></td><td><span class="math inline">\(X(z^k)\)</span></td><td><span class="math inline">\(R^{1/k}\)</span></td></tr><tr class="odd"><td>共轭</td><td><span class="math inline">\(x^*[n]\)</span></td><td><span class="math inline">\(X^*(z^*)\)</span></td><td><span class="math inline">\(R\)</span></td></tr><tr class="even"><td>卷积</td><td><span class="math inline">\(x_1[n] * x_2[n]\)</span></td><td><span class="math inline">\(X_1(z)X_2(z)\)</span></td><td>至少是<span class="math inline">\(R_1,R_2\)</span>相交</td></tr><tr class="odd"><td>一次差分</td><td><span class="math inline">\(x[n] - x[n-1]\)</span></td><td><span class="math inline">\((1 - z^{-1})X(z)\)</span></td><td>至少是<span class="math inline">\(R\)</span>和<spanclass="math inline">\(| z| &gt; 0\)</span>的相交</td></tr><tr class="even"><td>累加</td><td><span class="math inline">\(\sum_{k = -\infty}^{n}x[k]\)</span></td><td><span class="math inline">\(\frac{1}{1 - z^{-1}} X(z)\)</span></td><td>至少是<span class="math inline">\(R\)</span>和<spanclass="math inline">\(| z| &gt;1\)</span>的相交</td></tr><tr class="odd"><td>z域微分</td><td><span class="math inline">\(nx[n]\)</span></td><td><span class="math inline">\(-z\frac{dX(z)}{dz}\)</span></td><td><span class="math inline">\(R\)</span></td></tr></tbody></table><p>初值定理：若<spanclass="math inline">\(n&lt;0,x[n]=0\)</span>，则<spanclass="math inline">\(x[0] = \lim_{z\to \infty} X(z)\)</span></p><h2id="z变换与离散时间傅里叶变换关系">z变换与离散时间傅里叶变换关系</h2><p>当<span class="math inline">\(|z| =1\)</span>时，z变换就是离散时间傅里叶变换。当z变换的收敛域包括单位圆时，其离散时间傅里叶变换收敛。</p><h2 id="z变换matlab代码">z变换matlab代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms n         <span class="hljs-comment">% n是符号变量，后面的运算都是符号运算</span><br>f = <span class="hljs-built_in">sin</span>(n);<br>F = ztrans(f);<br><span class="hljs-built_in">disp</span>(F);<br>w0 = <span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>/<span class="hljs-number">800</span>;<br>A  = <span class="hljs-number">10</span>;<br>phi= <span class="hljs-built_in">pi</span>/<span class="hljs-number">6</span>;<br><br>y = <span class="hljs-built_in">cos</span>(w0*n + phi) + A*<span class="hljs-built_in">sin</span>(w0*n);<br>Y = ztrans(y);<br><span class="hljs-built_in">disp</span>(Y);<br>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>fplot(F);<br>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<br>fplot(Y);<br><br>st = heaviside(n); <span class="hljs-comment">% 阶跃信号的符号函数</span><br>ST = ztrans(st);<br><span class="hljs-built_in">disp</span>(ST);<br>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br>fplot(ST);<br></code></pre></td></tr></table></figure><h2 id="matlab中的z逆变换">matlab中的z逆变换</h2><p>matlab中的z逆变换结果都是因果序列，所以不用指定收敛域</p><p>参考https://ww2.mathworks.cn/help/symbolic/sym.iztrans.html<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms z n;<br>a = <span class="hljs-number">2</span>;<br><br>F = a*z^(<span class="hljs-number">-1</span>) / (<span class="hljs-number">1</span> - a*z^(<span class="hljs-number">-1</span>))^<span class="hljs-number">2</span>;<br>f = iztrans(F, n);<br><span class="hljs-built_in">disp</span>(f);<br><br></code></pre></td></tr></table></figure></p><h2 id="lti系统与z变换">LTI系统与z变换</h2><p>在离散线性时不变系统的分析和表示中，z变换发挥特别重要的作用 <spanclass="math display">\[Y(z) = X(z)H(z)\]</span></p><p><spanclass="math inline">\(H(z)\)</span>称为传递函数，是系统单位脉冲响应的z变换。只要单位圆在传函的收敛域内，将<span class="math inline">\(z =e^{jw}\)</span>带入<span class="math inline">\(H(z)\)</span>，则<spanclass="math inline">\(H(z)\)</span>变成系统的频率响应（z变换与傅里叶变换的关系）。</p><h3 id="因果系统">因果系统</h3><p>一个离散线性时不变系统，<spanclass="math inline">\(H(z)\)</span>的收敛域在某个圆的外边，包括无穷远点，该系统是因果的。对应前文因果序列的收敛域。h(n)为因果序列。</p><p>若<spanclass="math inline">\(H(z)\)</span>表示成多项式之比，其分子阶次不能高于分母阶次。</p><p>因果系统的初始松弛条件：<span class="math inline">\(if ~ x[n] = 0, n&lt; n_0 ~~ then ~ y[n] = 0, n &lt; n_0\)</span>，其中<spanclass="math inline">\(y[n] = \sum_{k = n_0}^{\infty}x[k]h[n-k]\)</span></p><p>满足因果性的LTI系统在未开始输入的情况下是不会有输出的</p><p>如果一个LTI系统是因果的，那么该系统就满足初始松弛条件；如果一个系统由线性常系数差分方程表征，并满足初始松弛条件，那么这就是一个满足因果性的LTI系统。</p><h2id="lti系统的差分方程与matlab代码">LTI系统的差分方程与matlab代码</h2><p>matlab中系统的差分方程一般形式： <span class="math display">\[\sum_{k = 1}^{N} a[k]y[n-(k-1)] = \sum_{m = 1}^{M} b[m]x[n - (m-1)]\]</span> 利用z变换的时移性质，其系统传函表示为： <spanclass="math display">\[Y(z) = \frac{ b[1] + b[2]z^{-1} + b[3]z^{-2} ... + b[M]z^{-(M-1)} }{a[1] + a[2]z^{-1} + a[3]z^{-2} ... + a[N]z^{-(N-1) }} X(z)\]</span></p><p>一个离散线性时不变系统的稳定性等效于单位脉冲响应是绝对可和的。这种情况下h[n]的傅里叶变换收敛，所以传递函数的收敛域要包括单位圆。</p><p>以下代码分别演示了稳定与不稳定系统的分析：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs matlab">b1 = [<span class="hljs-number">-4</span> <span class="hljs-number">5</span>];<br>a1 = [<span class="hljs-number">1</span> <span class="hljs-number">-6</span> <span class="hljs-number">9</span>]; <span class="hljs-comment">% 不稳定系统</span><br><br>[r,p,k] = residuez(b1,a1);<br><br><span class="hljs-built_in">disp</span>(r);<br><span class="hljs-built_in">disp</span>(p);<br><span class="hljs-built_in">disp</span>(k);<br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>);<br><br>zplane(b1,a1);<br><br>h=[<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-number">20</span>),<span class="hljs-number">1</span>,<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>)];<br><br>y=filter(b1,a1,h);<br>n=<span class="hljs-number">-20</span>:<span class="hljs-number">1000</span>;<br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>);<br><br>stem(n,y);<br>xlabel(<span class="hljs-string">&#x27;n&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;h(n)&#x27;</span>);<br><br>b2=<span class="hljs-number">1</span>;<br>a2=[<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0.9</span>]; <span class="hljs-comment">% 稳定系统</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">3</span>);<br>zplane(b2,a2);<br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">4</span>);<br>y2 = filter(b2,a2,h);<br>stem(n,y2);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>matlab-notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>matlab</tag>
      
      <tag>z变换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>matlab_learning_1</title>
    <link href="/2024/07/08/matlab-learning-1/"/>
    <url>/2024/07/08/matlab-learning-1/</url>
    
    <content type="html"><![CDATA[<h1id="尝试自己写一个离散信号卷积程序">尝试自己写一个离散信号卷积程序</h1><h2 id="离散信号卷积公式">离散信号卷积公式</h2><p>离散信号卷积公式： <span class="math display">\[y[n] = \sum_{k = -\infty}^{+\infty} x[k]h[n-k]\]</span></p><p>直接将公式翻译成matlab代码。代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><br>A = <span class="hljs-number">5</span>;                         <span class="hljs-comment">% 幅度</span><br>w0 = <span class="hljs-number">50e3</span>*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>;                <span class="hljs-comment">% 圆频率</span><br>phi = <span class="hljs-built_in">pi</span>/<span class="hljs-number">2</span>;                    <span class="hljs-comment">% 相位</span><br>t = <span class="hljs-number">0</span> : <span class="hljs-number">1</span>/<span class="hljs-number">50e3</span>/<span class="hljs-number">50</span> : <span class="hljs-number">1</span>/<span class="hljs-number">50e3</span>*<span class="hljs-number">10</span>; <span class="hljs-comment">% 时间向量</span><br><br>y = A*<span class="hljs-built_in">sin</span>(w0*t + phi);         <span class="hljs-comment">% 待卷积信号y</span><br><br>subplot(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);                <span class="hljs-comment">% 生成5行1列的曲线图，当前曲线图位置在第1行</span><br><span class="hljs-built_in">plot</span>(t,y);<br><span class="hljs-comment">% axis equal;</span><br>                               <span class="hljs-comment">% 待卷积信号z</span><br>z = <span class="hljs-number">2</span>*A*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*w0*t + phi) .* <span class="hljs-built_in">exp</span>(<span class="hljs-number">-20000</span>*t);<br><br>subplot(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);                <span class="hljs-comment">% 生成5行1列的曲线图，当前曲线图位置在第2行</span><br><span class="hljs-built_in">plot</span>(t, z);<br><span class="hljs-comment">% axis equal;</span><br><br>L = <span class="hljs-built_in">length</span>(t);                 <span class="hljs-comment">% t向量的长度L = 501，下标从1开始，到501结束</span><br>answer = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,L*<span class="hljs-number">2</span>);         <span class="hljs-comment">% answer向量用于存放卷积结果，卷积结果长度为 L + L - 1</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">2</span>:<span class="hljs-number">2</span>*L                  <span class="hljs-comment">% 从下标2开始存放卷积结果，因为信号向量下标从1开始，</span><br>    <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:L                <span class="hljs-comment">% 只有当i=2,k=1时下标有效</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">i</span>-k &gt;= <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">i</span>-k &lt;= <span class="hljs-number">501</span>)<br>            answer(<span class="hljs-built_in">i</span>) = answer(<span class="hljs-built_in">i</span>) + y(k) * z(<span class="hljs-built_in">i</span>-k);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>subplot(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);                <span class="hljs-comment">% 生成5行1列的曲线图，当前曲线图位置在第3行</span><br><span class="hljs-built_in">plot</span>(answer(<span class="hljs-number">2</span>:L*<span class="hljs-number">2</span>));<br><br></code></pre></td></tr></table></figure><h2 id="conv函数">conv函数</h2><p>matlab中卷积函数名为<code>conv</code>，用法很简单<code>answer2 = conv(y,z)</code>，因为向量<code>y</code>，<code>z</code>的长度都是501，所以<code>answer2</code>长度501+501-1=1001</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">answer2 = conv(y,z);           <span class="hljs-comment">% 使用matlab内部卷积函数</span><br>subplot(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>);                <span class="hljs-comment">% 生成5行1列的曲线图，当前曲线图位置在第4行</span><br><span class="hljs-built_in">plot</span>(answer2);<br></code></pre></td></tr></table></figure><h2 id="检验">检验</h2><p>最后新建一个数组存放两个卷积结果的差值，用于判断自己写的卷积程序正确性<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">delta_ans = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>, L*<span class="hljs-number">2</span>);     <span class="hljs-comment">% 两个卷积结果做差比较</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:L*<span class="hljs-number">2</span><span class="hljs-number">-1</span><br>    delta_ans(<span class="hljs-built_in">i</span>) = answer2(<span class="hljs-built_in">i</span>) - answer(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">end</span><br><br>subplot(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);                <span class="hljs-comment">% 生成5行1列的曲线图，当前曲线图位置在第5行</span><br><span class="hljs-built_in">plot</span>(delta_ans);               <span class="hljs-comment">% 可以看到结果相差不大</span><br></code></pre></td></tr></table></figure></p><h2 id="完整代码">完整代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><br>A = <span class="hljs-number">5</span>;                         <span class="hljs-comment">% 幅度</span><br>w0 = <span class="hljs-number">50e3</span>*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>;                <span class="hljs-comment">% 圆频率</span><br>phi = <span class="hljs-built_in">pi</span>/<span class="hljs-number">2</span>;                    <span class="hljs-comment">% 相位</span><br>t = <span class="hljs-number">0</span> : <span class="hljs-number">1</span>/<span class="hljs-number">50e3</span>/<span class="hljs-number">50</span> : <span class="hljs-number">1</span>/<span class="hljs-number">50e3</span>*<span class="hljs-number">10</span>; <span class="hljs-comment">% 时间向量</span><br><br>y = A*<span class="hljs-built_in">sin</span>(w0*t + phi);         <span class="hljs-comment">% 待卷积信号y</span><br><br>subplot(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);                <span class="hljs-comment">% 生成5行1列的曲线图，当前曲线图位置在第1行</span><br><span class="hljs-built_in">plot</span>(t,y);<br><span class="hljs-comment">% axis equal;</span><br>                               <span class="hljs-comment">% 待卷积信号z</span><br>z = <span class="hljs-number">2</span>*A*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*w0*t + phi) .* <span class="hljs-built_in">exp</span>(<span class="hljs-number">-20000</span>*t);<br><br>subplot(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);                <span class="hljs-comment">% 生成5行1列的曲线图，当前曲线图位置在第2行</span><br><span class="hljs-built_in">plot</span>(t, z);<br><span class="hljs-comment">% axis equal;</span><br><br>L = <span class="hljs-built_in">length</span>(t);                 <span class="hljs-comment">% t向量的长度L = 501，下标从1开始，到501结束</span><br>answer = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,L*<span class="hljs-number">2</span>);         <span class="hljs-comment">% answer向量用于存放卷积结果，卷积结果长度为 L + L - 1</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">2</span>:<span class="hljs-number">2</span>*L                  <span class="hljs-comment">% 从下标2开始存放卷积结果，因为信号向量下标从1开始，</span><br>    <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:L                <span class="hljs-comment">% 只有当i=2,k=1时下标有效</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">i</span>-k &gt;= <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">i</span>-k &lt;= <span class="hljs-number">501</span>)<br>            answer(<span class="hljs-built_in">i</span>) = answer(<span class="hljs-built_in">i</span>) + y(k) * z(<span class="hljs-built_in">i</span>-k);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>subplot(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);                <span class="hljs-comment">% 生成5行1列的曲线图，当前曲线图位置在第3行</span><br><span class="hljs-built_in">plot</span>(answer(<span class="hljs-number">2</span>:L*<span class="hljs-number">2</span>));<br><br>answer2 = conv(y,z);           <span class="hljs-comment">% 使用matlab内部卷积函数</span><br>subplot(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>);                <span class="hljs-comment">% 生成5行1列的曲线图，当前曲线图位置在第4行</span><br><span class="hljs-built_in">plot</span>(answer2);<br><br><br>delta_ans = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>, L*<span class="hljs-number">2</span>);     <span class="hljs-comment">% 两个卷积结果做差比较</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:L*<span class="hljs-number">2</span><span class="hljs-number">-1</span><br>    delta_ans(<span class="hljs-built_in">i</span>) = answer2(<span class="hljs-built_in">i</span>) - answer(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">end</span><br><br>subplot(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);                <span class="hljs-comment">% 生成5行1列的曲线图，当前曲线图位置在第5行</span><br><span class="hljs-built_in">plot</span>(delta_ans);               <span class="hljs-comment">% 可以看到结果相差不大</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>matlab-notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>matlab</tag>
      
      <tag>卷积</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test_page</title>
    <link href="/2024/07/06/test-page/"/>
    <url>/2024/07/06/test-page/</url>
    
    <content type="html"><![CDATA[<h1 id="波函数">波函数</h1><p>粒子的波函数<span class="math inline">\(\Psi(x,t)\)</span>（一维）或<span class="math inline">\(\Psi(\boldsymbol{r},t)\)</span>（三维）是复域函数，不能直接平方。而应该用模平方<spanclass="math inline">\(|\Psi(\boldsymbol{r}, t)|^2 \equiv \Psi^*\Psi\)</span>。<spanclass="math inline">\(\Psi\)</span>的共轭复数是<spanclass="math inline">\(\Psi^{*}\)</span>。全空间的概率密度积分为1，即<spanclass="math inline">\(\int \Psi^* \Psi dV = 1\)</span></p><h1 id="量子力学的基本假设">量子力学的基本假设</h1><p>粒子的波函数<span class="math inline">\(\Psi(\boldsymbol{r},t) =\psi_0 e^{i(\boldsymbol{k\cdot r}-wt)}\)</span></p><p>能量、动量变换<span class="math inline">\(E\)</span> -&gt; <spanclass="math inline">\(i\hbar\frac{\partial}{\partial t}\)</span>， <spanclass="math inline">\(\boldsymbol{P}\)</span> -&gt; <spanclass="math inline">\(-i\hbar \nabla\)</span></p><h1 id="薛定谔方程一般形式">薛定谔方程一般形式</h1><p>薛定谔方程一般形式： <span class="math display">\[\left[ -\frac{\hbar^2}{2m} \nabla^2 + V(\boldsymbol{r}) \right]\Psi(\boldsymbol{r}, t) = i\hbar\frac{\partial}{\partialt}\Psi(\boldsymbol{r}, t)\]</span> 其对应粒子质量<spanclass="math inline">\(m\)</span>，动量<spanclass="math inline">\(\boldsymbol{p}\)</span>，在势场<spanclass="math inline">\(V(\boldsymbol{r})\)</span>中的粒子能量表达式：<span class="math display">\[E = \frac{\boldsymbol{p}^2}{2m} + V(\boldsymbol{r})\]</span></p><p>薛定谔方程为线性微分方程，所以方程的解可以线性叠加，波函数是方程的解，所以波函数可以线性叠加</p><h1 id="定态薛定谔方程">定态薛定谔方程</h1><p><spanclass="math inline">\(V(\boldsymbol{r})\)</span>不显含时间t，可以用变数分离法求薛定谔方程特解。令<spanclass="math inline">\(\Psi(\boldsymbol{r}, t) =\psi(\boldsymbol{r})T(t)\)</span> 两边除以<spanclass="math inline">\(\psi T\)</span>得到 <span class="math display">\[\frac{1}{\psi} \left[ -\frac{\hbar^2}{2m} \nabla^2 + V(\boldsymbol{r})\right]\psi = \frac{i\hbar}{T} \frac{dT}{dt}\]</span> 令<spanclass="math inline">\(E\)</span>为分离常数，其具有能量量纲，与<spanclass="math inline">\(\boldsymbol{r},t\)</span>无关 <spanclass="math display">\[\frac{i\hbar}{T} \frac{dT}{dt} = E \tag{1}\]</span> <span class="math display">\[\frac{1}{\psi} \left[ -\frac{\hbar^2}{2m} \nabla^2 + V(\boldsymbol{r})\right]\psi = E \tag{2}\]</span> 解<span class="math inline">\((1)\)</span>得<spanclass="math inline">\(T=T_0e^{-iEt/\hbar}\)</span>。把常数<spanclass="math inline">\(T_0\)</span>归到<spanclass="math inline">\(\psi\)</span>中，<spanclass="math inline">\(\Psi(\boldsymbol{r}, t) =\psi(\boldsymbol{r})e^{-iEt/\hbar}\)</span>。</p><p>概率密度<span class="math inline">\(\Psi^*\Psi =\psi^*\psi\)</span>与时间无关</p><p>式<span class="math inline">\((2)\)</span>就是定态薛定谔方程 <spanclass="math display">\[\left[ -\frac{\hbar^2}{2m} \nabla^2 + V(\boldsymbol{r}) \right]\psi =E\psi\]</span></p>]]></content>
    
    
    <categories>
      
      <category>rydberg-atoms-notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
